[comment encoding = UTF-8 /]
[module generateImplementationTest('http://www.eclipse.org/emf/2002/Ecore')/]

[import soft::generator::go::generateCommon/]
[import soft::generator::go::generateType/]
[import soft::generator::go::test::generateType/]
[import soft::generator::go::lib::generateCommon/]
[import soft::generator::go::lib::generateReflectives/]
[import soft::generator::go::lib::generateOperation/]
[import soft::generator::go::lib::generateStructuralFeature/]
[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateReflectives/]

[template public generateImplementationTest(aClass : EClass) { implementationName : String = aClass.getImplementationName(); aPackage : EPackage = aClass.ePackage } ]
[file (aClass.ePackage.getOutputDirectory() + '/' + aClass.getImplementationTestFileName( aClass.name ), false, 'UTF-8')]
[fileComment()/]

package [aPackage.name/]

import (
	_ "testing"
	_ "time"

	_ "github.com/stretchr/testify/assert"
	_ "github.com/stretchr/testify/mock"
	[if not aPackage.isEcorePackage()]_ "github.com/masagroup/soft/go/ecore"[/if]
)

[aClass.eStructuralFeatures->select(isField()).generateTestImplementation()/]
[aClass.eOperations->select(isDefault()).generateTestOperation()/]
[/file]
[/template]

[template private generateTestOperation(anEOperation : EOperation)]
func Test[anEOperation.eContainingClass.name.toUpperFirst()/][anEOperation.getFunctionName()/]Operation(t *testing.T) {
	obj := [anEOperation.eContainingClass.getConstructorName()/]()
	assert.Panics(t, func() { obj.[anEOperation.getFunctionName()/]([anEOperation.generateParameterListNames()/]) })
}

[/template]

[template private generateTestImplementation(aStructuralFeature : EStructuralFeature)]
[if isGet() and isSet() and not isBidirectional() and not isContains()]
[aStructuralFeature.generateGetSetTestImplementation()/]
[/if]
[if isSet()]
[aStructuralFeature.generateSetTestImplementation()/]
[/if]
[if isGet() and isListType()]
[aStructuralFeature.generateGetListTestImplementation()/]
[/if]
[if aStructuralFeature.eContainingClass.getEGetFeatures()->notEmpty()]
[aStructuralFeature.generateEGetTestImplementation()/]
[/if]
[if aStructuralFeature.eContainingClass.getEInvokeOperations()->notEmpty()]
[aStructuralFeature.generateEInvokeTestImplementation()/]
[/if]
[if aStructuralFeature.eContainingClass.getEIsSetFeatures()->notEmpty()]
[aStructuralFeature.generateEIsSetTestImplementation()/]
[/if]
[if aStructuralFeature.eContainingClass.getEUnSetFeatures()->notEmpty()]
[aStructuralFeature.generateEUnSetTestImplementation()/]
[/if]
[if aStructuralFeature.eContainingClass.getESetFeatures()->notEmpty()]
[aStructuralFeature.generateESetTestImplementation()/]
[/if]
[if aStructuralFeature.eContainingClass.getEInverseAddFeatures()->notEmpty()]
[aStructuralFeature.generateEInverseAddTestImplementation()/]
[/if]
[if aStructuralFeature.eContainingClass.getEInverseRemoveFeatures()->notEmpty()]
[aStructuralFeature.generateEInverseRemoveTestImplementation()/]
[/if]
[/template]

[template private generateGetSetTestImplementation(aStructuralFeature : EStructuralFeature)]
[let varName : String = aStructuralFeature.getVariableName() ]
[let varAssigned : String = aStructuralFeature.getUnitTestType() ]
func Test[aStructuralFeature.eContainingClass.name.toUpperFirst()/][name.toUpperFirst()/]Get(t *testing.T) {
	obj := [aStructuralFeature.eContainingClass.getConstructorName()/]()
	obj.[aStructuralFeature.getSetterName()/]([varAssigned/])
	assert.Equal(t, [varAssigned/], obj.[aStructuralFeature.getGetterName()/]())
}
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature)]
[let varName : String = aStructuralFeature.getVariableName() ]
[let varAssigned : String = aStructuralFeature.getUnitTestType() ]
func Test[aStructuralFeature.eContainingClass.name.toUpperFirst()/][name.toUpperFirst()/]Set(t *testing.T) {
	mockAdapter := &[if not aStructuralFeature.eContainingClass.ePackage.isEcorePackage()]ecore.[/if]MockEAdapter{}
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	obj := [aStructuralFeature.eContainingClass.getConstructorName()/]()
	obj.EAdapters().Add(mockAdapter)
	obj.[aStructuralFeature.getSetterName()/]([varAssigned/])
	mockAdapter.AssertExpectations(t)
}
[/let]
[/let]
[/template]

[template private generateUnsetTestImplementation(aStructuralFeature : EStructuralFeature)]
[let varName : String = aStructuralFeature.getVariableName() ]
[let varAssigned : String = aStructuralFeature.getUnitTestType() ]
func Test[aStructuralFeature.eContainingClass.name.toUpperFirst()/][name.toUpperFirst()/]Unset(t *testing.T) {
	obj := [aStructuralFeature.eContainingClass.getConstructorName()/]()
	obj.[aStructuralFeature.getUnSetterName()/]()
[if aStructuralFeature.isListType()]
	assert.Equal(t, 0, obj.[varName/].Size())
[else]
	assert.Equal(t, [aStructuralFeature.eType.getDefaultValue()/], obj.[varName/])
[/if]
}
[/let]
[/let]
[/template]

[template private generateGetListTestImplementation(aStructuralFeature : EStructuralFeature)]
[let varName : String = aStructuralFeature.getVariableName() ]
[let varAssigned : String = aStructuralFeature.getUnitTestType() ]
func Test[aStructuralFeature.eContainingClass.name.toUpperFirst()/][name.toUpperFirst()/]GetList(t *testing.T) {
	obj := [aStructuralFeature.eContainingClass.getConstructorName()/]()
	[if aStructuralFeature.eType.name = 'EFeatureMapEntry' or aStructuralFeature.volatile]
	assert.Nil(t, obj.[aStructuralFeature.getGetterName()/]())
	[else]
	assert.NotNil(t, obj.[aStructuralFeature.getGetterName()/]())
	[/if]
}
[/let]
[/let]
[/template]

[template private generateEGetTestImplementation(aStructuralFeature : EStructuralFeature)]
func Test[aStructuralFeature.eContainingClass.name.toUpperFirst()/][name.toUpperFirst()/]EGet(t *testing.T) {
	obj := [aStructuralFeature.eContainingClass.getConstructorName()/]()
	[for (anStructFeature : EStructuralFeature | aStructuralFeature.eContainingClass.eStructuralFeatures->asOrderedSet()->sortedBy(name))]
    {
    [let lazy : String = anStructFeature.getLazy()]
		[if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
		[elseif not anStructFeature.isContainer() and anStructFeature.isVolatile() and not anStructFeature.hasKey('getterBody')]
		assert.Panics(t, func() { obj.EGetFromID([anStructFeature.getQualifiedFeatureIDName()/], false, false) })
		[elseif not anStructFeature.isContainer() and not anStructFeature.isVolatile() and lazy <> 'no' and lazy = 'action']
		_ = obj
		[else]
		assert.Equal(t, obj.[anStructFeature.getGetterName()/](), obj.EGetFromID([anStructFeature.getQualifiedFeatureIDName()/], false, false))
		[/if]
	[/let]
	}
    [/for]
}

[/template]

[template private generateEInvokeTestImplementation(aStructuralFeature : EStructuralFeature)]
func Test[aStructuralFeature.eContainingClass.name.toUpperFirst()/][name.toUpperFirst()/]EInvoke(t *testing.T) {
	obj := [aStructuralFeature.eContainingClass.getConstructorName()/]()
    [for ( eOperation : EOperation | aStructuralFeature.eContainingClass.getEInvokeOperations()->sortedBy(name) )]
    {
		assert.Panics(t, func() { obj.EInvokeFromID([eOperation.eContainingClass.getOperationIDName(eOperation)/], nil) })
	}
    [/for]
}

[/template]

[template private generateEIsSetTestImplementation(aStructuralFeature : EStructuralFeature)]
func Test[aStructuralFeature.eContainingClass.name.toUpperFirst()/][name.toUpperFirst()/]EIsSet(t *testing.T) {
	obj := [aStructuralFeature.eContainingClass.getConstructorName()/]()
	[for (anStructFeature : EStructuralFeature | aStructuralFeature.eContainingClass.getEIsSetFeatures()->sortedBy(name))]
	{
		[if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
		[elseif anStructFeature.isListType()]
		    [if anStructFeature.isField()]
		assert.Equal(t, obj.[anStructFeature.name/] != nil && obj.[anStructFeature.name/].Size() != 0, obj.EIsSetFromID([anStructFeature.getQualifiedFeatureIDName()/]))
		    [else]
		assert.Equal(t, obj.[anStructFeature.getGetterName()/]().Size() != 0, obj.EIsSetFromID([anStructFeature.getQualifiedFeatureIDName()/]))
		    [/if]
		[else]
		    [let accessor : String = if isField() then anStructFeature.getVariableName() else anStructFeature.getGetterName()+'()' endif]
		    [if eType.oclIsKindOf(EEnum)]
		assert.Equal(t, obj.[accessor/] != [anStructFeature.oclAsType(EAttribute).generateDefaultValue()/], obj.EIsSetFromID([anStructFeature.getQualifiedFeatureIDName()/]))
		    [else]
		_ = obj
		    [/if]
		    [/let]
		[/if]
	}
	[/for]
}

[/template]

[template private generateEUnSetTestImplementation(aStructuralFeature : EStructuralFeature)]
func Test[aStructuralFeature.eContainingClass.name.toUpperFirst()/][name.toUpperFirst()/]EUnset(t *testing.T) {
	obj := [aStructuralFeature.eContainingClass.getConstructorName()/]()
    [for (anStructFeature : EStructuralFeature | aStructuralFeature.eContainingClass.getEUnSetFeatures()->sortedBy(name))]
	{
    [if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
	[elseif anStructFeature.isListType() and not anStructFeature.isUnSettable()]
		obj.EUnsetFromID([anStructFeature.getQualifiedFeatureIDName()/])
        obj.[anStructFeature.getGetterName()/]().Clear()
		assert.Equal(t, 0, obj.[anStructFeature.getGetterName()/]().Size())
	[else]
		_ = obj
    [/if]
	}
	[/for]
}

[/template]

[template private generateESetTestImplementation(aStructuralFeature : EStructuralFeature)]
func Test[aStructuralFeature.eContainingClass.name.toUpperFirst()/][name.toUpperFirst()/]ESet(t *testing.T) {
	obj := [aStructuralFeature.eContainingClass.getConstructorName()/]()
    [for (anStructFeature : EStructuralFeature | aStructuralFeature.eContainingClass.getESetFeatures()->sortedBy(name))]
	{
	[let varAssigned : String = anStructFeature.getUnitTestType() ]
    [if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
	[elseif anStructFeature.isListType()]
		elem := [varAssigned/]
		obj.ESetFromID([anStructFeature.getQualifiedFeatureIDName()/], elem)
		assert.Equal(t, 1, obj.[anStructFeature.getGetterName()/]().Size())
		assert.Equal(t, elem, obj.[anStructFeature.getGetterName()/]().Get(0))
	[else]
		_ = obj
    [/if]
	[/let]
	}
	[/for]
}

[/template]

[template private generateEInverseAddTestImplementation(aStructuralFeature : EStructuralFeature)]
func Test[aStructuralFeature.eContainingClass.name.toUpperFirst()/][name.toUpperFirst()/]EInverseAdd(t *testing.T) {
	[for ( aFeature : EStructuralFeature | aStructuralFeature.eContainingClass.getEInverseAddFeatures()->sortedBy(name) )]
	{
		[if aFeature.eType.name = 'EFeatureMapEntry' or aFeature.volatile]
		_ = obj
		[elseif aFeature.isListType()]
		obj := [aStructuralFeature.eContainingClass.getConstructorName()/]()
		obj.EBasicInverseAdd(&[if not aStructuralFeature.eContainingClass.ePackage.isEcorePackage()]ecore.[/if]MockEObject{}, [aFeature.getQualifiedFeatureIDName()/], &[if not aStructuralFeature.eContainingClass.ePackage.isEcorePackage()]ecore.[/if]MockENotificationChain{})
		assert.Equal(t, 1, obj.[aFeature.getGetterName()/]().Size())
		[/if]
	}
	[/for]
}

[/template]

[template private generateEInverseRemoveTestImplementation(aStructuralFeature : EStructuralFeature)]
func Test[aStructuralFeature.eContainingClass.name.toUpperFirst()/][name.toUpperFirst()/]EInverseRemove(t *testing.T) {
	[for ( aFeature : EStructuralFeature | aStructuralFeature.eContainingClass.getEInverseRemoveFeatures()->sortedBy(name) )]
	{
		[if aFeature.eType.name = 'EFeatureMapEntry' or aFeature.volatile]
		_ = obj
		[elseif aFeature.isListType()]
		obj := [aStructuralFeature.eContainingClass.getConstructorName()/]()
		mock := &[if not aStructuralFeature.eContainingClass.ePackage.isEcorePackage()]ecore.[/if]MockEObject{}
		obj.[aFeature.getGetterName()/]().Add(mock)
		obj.EBasicInverseRemove(mock, [aFeature.getQualifiedFeatureIDName()/], &[if not aStructuralFeature.eContainingClass.ePackage.isEcorePackage()]ecore.[/if]MockENotificationChain{})
		assert.Equal(t, 0, obj.[aFeature.getGetterName()/]().Size())
		[/if]
	}
	[/for]
}

[/template]
