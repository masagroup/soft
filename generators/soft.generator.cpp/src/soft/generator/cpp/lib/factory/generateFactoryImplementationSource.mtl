[comment encoding = UTF-8 /]
[module generateFactoryImplementationSource('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::generateClass /]
[import soft::generator::cpp::generateType /]
[import soft::generator::cpp::generateCommon /]
[import soft::generator::cpp::lib::generateCommon /]

[template public generateFactoryImplementationSource(anEPackage : EPackage) { className : String = anEPackage.getFactoryImplementationName() ; namespaceName : String = anEPackage.getImplementationNamespaceName(); }]
[file (anEPackage.getOutputDirectory() + '/src-gen/' + anEPackage.getImplementationFolder() + '/' + className + '.cpp', false, 'UTF-8')]
[fileComment()/]
#include "[namespaceToFolder(anEPackage.getFactoryQualifiedImplementationName())/].hpp"
[let includes : OrderedSet(String) = Set{ anEPackage.eAllContents(EClass)->collect( c | if c.hasExtension() then c.getQualifiedExtensionName() else c.getQualifiedImplementationName() endif)->asSet()
                                        , Set {
                                                    anEPackage.getQualifiedInterfaceName(),
                                                    anEPackage.getFactoryQualifiedInterfaceName(),
                                                    'ecore::EList',
                                                    'ecore::EClass'
                                              }
                                        }->flatten()->asOrderedSet()->sortedBy( s | s)]
[for ( include : String | includes )]
#include "[namespaceToFolder(include)/].hpp"
[/for]
[/let]

#include <iostream>
#include <boost/current_function.hpp>

[comment namespace /]
[let namespaces : OrderedSet(String) = OrderedSet{ 'ecore' , anEPackage.getInterfaceNamespaceName() , anEPackage.getImplementationNamespaceName(), anEPackage.getExtensionNamespaceName() }]
[for (namespace : String | namespaces )]
using namespace [namespace/];
[/for]
[/let]

//*********************************
// Constructor / Destructor
//*********************************

[className/]::[className/]()
{
}

[className/]::~[className/]()
{
}

[className/]* [className/]::create()
{
    return new [className/]();
}

//*********************************
// creators
//*********************************

std::shared_ptr<[getShortQualifiedName('ecore::EObject',namespaceName)/]> [className/]::create(const std::shared_ptr<[getShortQualifiedName('ecore::EClass',namespaceName)/]>&  eClass) const
{
    int classID = eClass->getClassifierID();
    switch(classID)
    {
    [for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) ? (aClass.abstract=false)]
        case [anEPackage.getInterfaceName()/]::[aClass.getClassifierIDName()/]:
            return this->create[aClass.name/]();
    [/for]
    default:
            std::cerr << BOOST_CURRENT_FUNCTION << " ID " << classID <<" not found" << std::endl;
    }
    return nullptr;
}

[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) ? (aClass.abstract=false)]
std::shared_ptr<[aClass.getInterfaceName()/]> [className/]::create[aClass.name/]() const
{
[let pointerName : String = if aClass.hasExtension() then aClass.getExtensionName() else aClass.getImplementationName() endif]
    std::shared_ptr<[pointerName/]> element( new [pointerName/]() );
[/let]
    element->[generateGetThisPtrPropertySetterName()/](element);
    return element;
}

[let ref : OrderedSet(EReference) = aClass.getAllContainers()]
[for(aReference:EReference | ref->sortedBy(name))]
std::shared_ptr<[aClass.getInterfaceName()/]> [className/]::create[aClass.name/]([aReference.generateParameterType()/] eContainer) const
{
    [generateCreateFunctionContent(aClass, ref, aReference, anEPackage, false)/]
}
[if(aClass.getElementIDAccessorName().size() > 0)]
std::shared_ptr<[aClass.getInterfaceName()/]> [className/]::create[aClass.name/]([aReference.generateParameterType()/] eContainer, const unsigned int classID) const
{
    [generateCreateFunctionContent(aClass, ref, aReference, anEPackage, true)/]
}[/if]

[/for]
[/let]
[/for]

std::shared_ptr<[anEPackage.getInterfaceName()/]> [className/]::get[anEPackage.getInterfaceName()/]() const
{
    return [anEPackage.getInterfaceName()/]::eInstance();
}
[/file]
[/template]

[template public generateCreateFunctionContent(aClass : EClass, ref : OrderedSet(EReference), aReference : EReference, anEPackage : EPackage, addID : Boolean)]
[if(addID)]
auto element = std::dynamic_pointer_cast< [aClass.getImplementationName()/] >( create[aClass.name/]() );
element->set[aClass.getElementIDAccessorName()/]ID(classID);
[else]
auto element = create[aClass.name/]();
[/if]
[if(not aReference.eOpposite.name.oclIsUndefined())]
if( eContainer)
[if(aReference.eOpposite.upperBound <> 1)]
    eContainer->get[aReference.eOpposite.name.toUpperFirst()/]()->add(element);
[else]
    eContainer->set[aReference.eOpposite.name.toUpperFirst()/](element);
[/if]
[/if]
return element;
[/template]
