[comment encoding = UTF-8 /]
[module generateStructuralFeature('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::generateCommon /]
[import soft::generator::cpp::generateType /]
[import soft::generator::cpp::generateClass /]

[query private getQualifiedFeatureID( aStructuralFeature : EStructuralFeature ) : String =
    aStructuralFeature.getPackageName(aStructuralFeature.eContainingClass) + '::' + aStructuralFeature.eContainingClass.getFeatureIDName( aStructuralFeature )
/]

[query public isBasicSet(aStructuralFeature : EStructuralFeature) : Boolean = not isListType() and ( isChangeable() or not isContainer() ) and ( isBidirectional() and not isVolatile() or isContains() ) /]
[query public isBasicGet(aStructuralFeature : EStructuralFeature) : Boolean = isResolveProxies() and not isListType()/]
[query public isBasicUnSet(aStructuralFeature : EStructuralFeature) : Boolean = isUnSettable() and isChangeable() and not isListType() and aStructuralFeature.oclIsKindOf(EReference) and ( isBidirectional() or isContains() )/]

[template public generateDeclaration(aStructuralFeature : EStructuralFeature, impl : Boolean )]
[if hasGetter('public',impl)]
[aStructuralFeature.generateGetDeclaration(impl)/]

[/if]
[if hasSetter('public',impl)]
[aStructuralFeature.generateSetDeclaration(impl)/]

[/if]
[/template]

[template public generateBasicDeclaration(aStructuralFeature : EStructuralFeature)]
[if isBasicGet()]
[aStructuralFeature.generateBasicGetDeclaration()/]

[/if]
[if isBasicSet()]
[aStructuralFeature.generateBasicSetDeclaration()/]

[/if]
[/template]


[template public generateDefinition(aStructuralFeature : EStructuralFeature)]
[if hasGetter('public',true)]
[aStructuralFeature.generateGetDefinition()/]

[/if]
[if hasSetter('public',true)]
[aStructuralFeature.generateSetDefinition()/]

[/if]
[/template]


[template public generateBasicDefinition(aStructuralFeature : EStructuralFeature)]
[if isBasicGet()]
[aStructuralFeature.generateBasicGetDefinition()/]

[/if]
[if isBasicSet()]
[aStructuralFeature.generateBasicSetDefinition()/]

[/if]
[/template]

[template public generateDataMember(aStructuralFeature : EStructuralFeature)]
[aStructuralFeature.generateDataType()/] [aStructuralFeature.name/]_;

[/template]

[template public generateBasicGetDeclaration(aStructuralFeature : EStructuralFeature)]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[let methodName : String = aStructuralFeature.getGetterName().toUpperFirst()]
[aStructuralFeature.generateReturnType()/] [className/]::basic[methodName/]() const; 
[/let]
[/let]
[/template]

[template public generateBasicGetDefinition(aStructuralFeature : EStructuralFeature)]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[let methodName : String = 'basic' + aStructuralFeature.getGetterName().toUpperFirst()]
[aStructuralFeature.generateReturnType()/] [className/]::[methodName/]() const 
{
    // [protected (className + '::' + methodName)]
[if isContainer()]
    if ( eContainerFeatureID() != [aStructuralFeature.getQualifiedFeatureID()/] )
        return [aStructuralFeature.generateEffectiveType()/]();
    else
        return std::dynamic_pointer_cast<[aStructuralFeature.eGenericType.generateCppType(false)/]>(eContainer());
[elseif not isVolatile()]
    return [aStructuralFeature.name/]_;
[elseif (hasKey('getterBody'))]
    [valueKey('getterBody')/]
[else]
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";    
[/if]
    // [/protected]
}
[/let]
[/let]
[/template]

[template public generateGetDeclaration(aStructuralFeature : EStructuralFeature, impl : EBoolean)]
virtual [aStructuralFeature.generateReturnType()/] [aStructuralFeature.getGetterName()/]() const [abstractSufix(impl)/];
[/template]

[template public generateGetDefinition(aStructuralFeature : EStructuralFeature)]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[aStructuralFeature.generateReturnType()/] [className/]::[aStructuralFeature.getGetterName()/]() const 
{
    // [protected (className + '::' + aStructuralFeature.getGetterName()) ]
[if not isVolatile() ]
    [if isListType() ]
    if ( ![aStructuralFeature.name/]_ )
        const_cast<[className/]*>(this)->[aStructuralFeature.name/]_.reset(new [getListConstructor()/]);
    return [aStructuralFeature.name/]_;
    [elseif isContainer()]
    if ( eContainerFeatureID() != [aStructuralFeature.getQualifiedFeatureID()/] )
        return [aStructuralFeature.generateEffectiveType()/]();
    else
        return std::dynamic_pointer_cast<[aStructuralFeature.eGenericType.generateCppType(false)/]>(eContainer());
    [elseif isResolveProxies()]
    // TO BE DONE
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";
    [else]
    return [aStructuralFeature.name/]_;
    [/if]
[elseif hasKey('getterBody')]
    [valueKey('getterBody')/]
[else]
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";
[/if]
    // [/protected]
}
[/let]
[/template]

[template public generateBasicSetDeclaration(aStructuralFeature : EStructuralFeature)]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[let methodName : String = 'basic' +aStructuralFeature.getSetterName().toUpperFirst()]
[let newVarName : String = 'new' + aStructuralFeature.getSafeName().toUpperFirst()]
std::shared_ptr<ecore::ENotificationChain> [className/]::[methodName/]( [aStructuralFeature.generateParameterType()/] [newVarName/] , const std::shared_ptr<ecore::ENotificationChain>& msgs ); 
[/let]
[/let]
[/let]
[/template]


[template public generateBasicSetDefinition(aStructuralFeature : EStructuralFeature)]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[let methodName : String = 'basic' +aStructuralFeature.getSetterName().toUpperFirst()]
[let newVarName : String = 'new' + aStructuralFeature.getSafeName().toUpperFirst()]
std::shared_ptr<ecore::ENotificationChain> [className/]::[methodName/]( [aStructuralFeature.generateParameterType()/] [newVarName/] , const std::shared_ptr<ecore::ENotificationChain>& msgs) 
{
    // [protected (className + '::' + methodName)]
[if isContainer()]
    return eBasicSetContainer([newVarName/],[aStructuralFeature.getQualifiedFeatureID()/],msgs); 
[elseif not isVolatile()]
    [let oldVarName : String = 'old' + aStructuralFeature.getSafeName().toUpperFirst()]
    auto [oldVarName/] = [newVarName/];
    [aStructuralFeature.getSafeName()/]_ = [newVarName/];
    auto notifications = msgs;
    if ( eNotificationRequired() )
    {
        auto notification = std::make_shared<Notification>( Notification::SET , getThisPtr() ,[aStructuralFeature.getQualifiedFeatureID()/], [oldVarName/], [newVarName/] );
        if (notifications)
            notifications->add( notification );
        else
            notifications = notification;
    }
    return notifications;
    [/let]
[elseif (hasKey('setterBody'))]
    [valueKey('setterBody')/]
[else]
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";    
[/if]
    // [/protected]
}
[/let]
[/let]
[/let]
[/template]

[template public generateSetDeclaration(aStructuralFeature : EStructuralFeature, impl : EBoolean)]
virtual void [aStructuralFeature.getSetterName()/]([aStructuralFeature.generateParameterType()/] [aStructuralFeature.getSafeName()/]) [abstractSufix(impl)/];
[/template]

[template public generateSetDefinition(aStructuralFeature : EStructuralFeature)]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[let methodName : String = aStructuralFeature.getSetterName()]
[let newVarName : String = 'new' + aStructuralFeature.getSafeName().toUpperFirst()]
void [className/]::[methodName/]([aStructuralFeature.generateParameterType()/] [newVarName/])
{
    // [protected (className + '::' + methodName)]
[if not isVolatile()]
    [if isContainer()]
    if ( [newVarName/] != eContainer() || ([newVarName/] && eContainerFeatureID() !=  [aStructuralFeature.getQualifiedFeatureID()/])) 
    {
        std::shared_ptr<ENotificationChain> notifications;
        if ( eContainer() )
            notifications = eBasicRemoveFromContainer(notifications);
        if ( [newVarName/] )
            notifications = [newVarName/]->eInverseAdd( getThisPtr() , [aStructuralFeature.getQualifiedFeatureID()/], notifications );
        notifications = basic[methodName.toUpperFirst()/]( [newVarName/], notifications );
        if ( notifications )
            notifications->dispatch();
    }
    else if ( eNotificationRequired() )
        eNotify( std::make_shared<Notification>(Notification::SET , getThisPtr() ,[aStructuralFeature.getQualifiedFeatureID()/], [newVarName/], [newVarName/]));
    [elseif isBidirectional() or isContains()]
    if ( [newVarName/] != [aStructuralFeature.getSafeName()/]_ )
    {
        std::shared_ptr<ENotificationChain> notifications;
        if ( [aStructuralFeature.getSafeName()/]_ )
        [if not isBidirectional()]
            notifications = [aStructuralFeature.getSafeName()/]_->eInverseRemove( getThisPtr(), EOPPOSITE_FEATURE_BASE - [aStructuralFeature.getQualifiedFeatureID()/] , notifications );
        if ( [newVarName/] )
            notifications = [newVarName/]->eInverseAdd( getThisPtr(), EOPPOSITE_FEATURE_BASE - [aStructuralFeature.getQualifiedFeatureID()/] , notifications );
        [else]
            [let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
            notifications = [aStructuralFeature.getSafeName()/]_->eInverseRemove( getThisPtr(), EOPPOSITE_FEATURE_BASE - [reverseFeature.getQualifiedFeatureID()/] , notifications );
        if ( [newVarName/] )
            notifications = [newVarName/]->eInverseAdd( getThisPtr(), EOPPOSITE_FEATURE_BASE - [reverseFeature.getQualifiedFeatureID()/] , notifications );
            [/let]
        [/if]
        notifications = basic[aStructuralFeature.getSetterName().toUpperFirst()/]([newVarName/],notifications);
        if (notifications)
            notifications->dispatch();
    }
        [if isUnSettable()]
        [/if]
    [else]
        [let oldVarName : String = 'old' + aStructuralFeature.getSafeName().toUpperFirst()]
    auto [oldVarName/] = [aStructuralFeature.getSafeName()/]_;
    [aStructuralFeature.getSafeName()/]_ = [newVarName/];
    if ( eNotificationRequired() )
        eNotify( std::make_shared<Notification>(Notification::SET , getThisPtr() ,[aStructuralFeature.getQualifiedFeatureID()/], [oldVarName/], [newVarName/]));
        [/let]
    [/if]
[elseif hasKey('setterBody')]
    [valueKey('setterBody')/] 
[else]
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";    
[/if]
    // [/protected]
}
[/let]
[/let]
[/let]
[/template]


[template private getListConstructor( anEAttribute : EStructuralFeature ) post(trim())]
[/template]

[template private getListConstructor( anEAttribute : EAttribute ) post(trim())]
BasicEList<[anEAttribute.eGenericType.generateCppType()/],[anEAttribute.unique/]>()
[/template]

[template private getListConstructor( anEReference : EReference ) post(trim())]
[let typeArgument : String = anEReference.eGenericType.generateCppType()]
[let thisPtrGetterName : String = anEReference.eContainingClass.generateGetThisPtrPropertyGetterName()]
[let packageName : String = anEReference.getPackageName(anEReference.eContainingClass)]
[let featureID : String = anEReference.eContainingClass.getFeatureIDName( anEReference )]
[if (anEReference.containment)]
    [if anEReference.eOpposite.oclIsUndefined() ]
        EObjectEList<[typeArgument/],true,true,false>([thisPtrGetterName/](), [anEReference.getQualifiedFeatureID()/] )
    [else]
        [let reverseFeature :EReference = anEReference.eOpposite ]
        EObjectEList<[typeArgument/],true,true,true>( [thisPtrGetterName/](), [anEReference.getQualifiedFeatureID()/] , [reverseFeature.getQualifiedFeatureID()/])
        [/let]
    [/if]
[else]
    [if anEReference.eOpposite.oclIsUndefined() ]
        EObjectEList<[typeArgument/],false,false,false>( [thisPtrGetterName/](), [packageName/]::[featureID/])
    [else]
        [let reverseFeature :EReference = anEReference.eOpposite ]
        EObjectEList<[typeArgument/],false,true,true>( [thisPtrGetterName/](), [anEReference.getQualifiedFeatureID()/] , [reverseFeature.getQualifiedFeatureID()/])
        [/let]
    [/if]
[/if]
[/let]
[/let]
[/let]
[/let]
[/template]


[template public generateStaticFeatureID(anStructFeature : EStructuralFeature,anEClass : EClass )]
/**
 * The feature id for the [anEClass.name/] '[anStructFeature.name.toUpperFirst()/]' [anStructFeature.getFeatureKind()/].
 */
static const int [anEClass.getFeatureIDName(anStructFeature)/] = [anEClass.getFeatureValue(anStructFeature)/];

[/template]

[template public generateStaticFeatureCountID(anEClass : EClass )]
/**
 * The number of structural features of the class [anEClass.name/].
 */
static const int [anEClass.getFeatureCountID()/] = [anEClass.getFeatureCountValue()/];

[/template]

