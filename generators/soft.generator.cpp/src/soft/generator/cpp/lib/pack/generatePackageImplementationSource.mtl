[comment encoding = UTF-8 /]
[module generatePackageImplementationSource('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::generateAttribute /]
[import soft::generator::cpp::generateClass /]
[import soft::generator::cpp::generateDataType /]
[import soft::generator::cpp::generateOperation /]
[import soft::generator::cpp::generateReference /]
[import soft::generator::cpp::generateCommon /]
[import soft::generator::cpp::lib::generateCommon /]
[import soft::generator::cpp::lib::pack::generatePackageHelper /]

[query public metaModelIncludes(anEPackage : EPackage) : Set(EPackage) = OrderedSet{anEPackage.eAllContents(EClass).eAllSuperTypes.ePackage,anEPackage.eAllContents(EStructuralFeature).eType.ePackage,anEPackage.eAllContents(EParameter).eType.ePackage}->flatten() /]

[template public generatePackageImplSource(anEPackage : EPackage) { packageName : String = anEPackage.name.toUpperFirst().concat('PackageImpl');}]
[file (getOutputDirectory().concat('/src-gen/').concat(anEPackage.name).concat('/impl/').concat(packageName).concat('.cpp'), false, 'UTF-8')]
#include "[anEPackage.name/]/impl/[packageName/].hpp"

#include "ecore/EList.hpp"

[if (anEPackage.getMetaMetaModelClasses()->notEmpty())]
//metamodel classes
[for (elements : EClassifier| anEPackage.getMetaMetaModelClasses())]
#include "[elements.ePackage.name/]/[elements.name.toUpperFirst()/].hpp"
[/for]
[/if]

// factory
#include "[anEPackage.name/]/[anEPackage.name.toUpperFirst().concat('Factory')/].hpp"

[if (anEPackage.metaModelIncludes()->notEmpty())]
//depending model packages
[for (pack : EPackage | anEPackage.metaModelIncludes()->asOrderedSet()->sortedBy(name)) ? (not ( pack=anEPackage))]
#include "[pack.name/]/[pack.name.concat('Package').toUpperFirst()/].hpp"
[/for]
[/if]

using namespace [anEPackage.name/];

[packageName/]::[packageName/]()
{
    setEFactoryInstance(std::shared_ptr<ecore::EFactory >( [anEPackage.name.concat('Factory').toUpperFirst()/]::eInstance()));
}

[packageName/]::~[packageName/]()
{
}

[packageName/]* [packageName/]::create()
{
    return new [packageName/]();
}

void [packageName/]::init(const std::shared_ptr<[packageName/]>& package)
{
    setThisPtr(package);
    createPackageContents(package);
    initializePackageContents();   
}

[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) separator ('\r\n')]
// Begin Class [aClass.name.toUpperFirst()/]
[aClass.generateModelElementGetterImpl(anEPackage)/]
[aClass.eAttributes->sortedBy(name).generateModelElementGetterImpl(anEPackage)/]
[aClass.eReferences->sortedBy(name).generateModelElementGetterImpl(anEPackage)/]
[aClass.eOperations->sortedBy(name).generateModelElementGetterImpl(anEPackage)/]
// End Class [aClass.name.toUpperFirst()/]
[/for]
[anEPackage.eAllContents(EDataType)->sortedBy(name).generateModelElementGetterImpl(anEPackage)/]
[/file]

[comment] create additional file for create function to reduce comiling time
[/comment]
[file (getOutputDirectory().concat('/src-gen/').concat(anEPackage.name).concat('/impl/').concat(packageName).concat('_Creation.cpp'), false, 'UTF-8')]
#include "[anEPackage.name/]/impl/[packageName/].hpp"

// metamodel factory
#include "[anEPackage.eClass().ePackage.name/]/[anEPackage.eClass().ePackage.name.toUpperFirst().concat('Factory')/].hpp"

#include <cassert>

[if (anEPackage.getMetaMetaModelClasses()->notEmpty())]
// metamodel classes
[for (elements : EClassifier| anEPackage.getMetaMetaModelClasses())]
#include "[elements.ePackage.name/]/[elements.name.toUpperFirst()/].hpp"
[/for]
[/if]

[if (anEPackage.metaModelIncludes()->notEmpty())]
// depending model packages
[for (pack : EPackage | anEPackage.metaModelIncludes()->asOrderedSet()->sortedBy(name)) ? (not ( pack=anEPackage))]
#include "[pack.name/]/[pack.name.concat('Package').toUpperFirst()/].hpp"
[/for]
[/if]

using namespace [anEPackage.name/];

void [packageName/]::createPackageContents(const std::shared_ptr<[packageName/]>& package)
{
    if (isCreated) 
        return;
    isCreated = true;

    std::shared_ptr<ecore::EcoreFactory> factory = ecore::EcoreFactory::eInstance();

[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name))]
    create[aClass.name.toUpperFirst()/]Content(package, factory);
[/for]

    createPackageEDataTypes(package, factory);
}

[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) separator ('\r\n')]
void [packageName/]::create[aClass.name.toUpperFirst()/]Content(const std::shared_ptr<[needNamespace(anEPackage,'EPackage')/]>& package, const std::shared_ptr<[needNamespace(anEPackage,'EcoreFactory')/]>& factory)
{
    [aClass.generateClassCreation()/]
    [aClass.eAttributes->sortedBy(name).generateAttributeCreation()/]
    [aClass.eReferences->sortedBy(name).generateReferenceCreation()/]
    [aClass.eOperations->sortedBy(name).generateOperationCreation()/]
}
[/for]

void [packageName/]::createPackageEDataTypes(const std::shared_ptr<[needNamespace(anEPackage,'EPackage')/]>& package, const std::shared_ptr<[needNamespace(anEPackage,'EcoreFactory')/]>& factory)
{
    [anEPackage.eAllContents(EDataType)->sortedBy(name).generateEDatatypeCreation()/]
}
[/file]

[comment] create additional file for initialize function to reduce comiling time
[/comment]
[file (getOutputDirectory().concat('/src-gen/').concat(anEPackage.name).concat('/impl/').concat(packageName).concat('_Initialization.cpp'), false, 'UTF-8')]
#include "[anEPackage.name/]/impl/[packageName/].hpp"

#include "ecore/EList.hpp"

//metametamodel classes
[for (elements : EClassifier| anEPackage.getMetaMetaModelClasses())]
#include "[elements.ePackage.name/]/[elements.name.toUpperFirst()/].hpp"
[/for]

// metametamodel factory
#include "[anEPackage.eClass().ePackage.name/]/[anEPackage.eClass().ePackage.name.toUpperFirst().concat('Factory')/].hpp"

//depending model packages
[for (pack : EPackage | anEPackage.metaModelIncludes()->asOrderedSet()->sortedBy(name)) ? (not ( pack=anEPackage))]
#include "[pack.name/]/[pack.name.concat('Package').toUpperFirst()/].hpp"
[/for]

using namespace [anEPackage.name/];

void [packageName/]::initializePackageContents()
{
    if (isInitialized)
        return;
    isInitialized = true;

    // Initialize package
    setName(eNAME);
    setNsPrefix(eNS_PREFIX);
    setNsURI(eNS_URI);
    
    // Add supertypes to classes
    [anEPackage.eAllContents(EClass)->sortedBy(name).initSuperTypes()/]

    // Initialize classes and features; add operations and parameters
[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name))]
    initialize[aClass.name.toUpperFirst()/]Content();
[/for]

    initializePackageEDataTypes();
}

[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) separator ('\r\n')]
void [packageName/]::initialize[aClass.name.toUpperFirst()/]Content()
{
    [aClass.generateClassInit()/]
    [aClass.eAttributes->sortedBy(name).generateAttributeInitialization()/]
    [aClass.eReferences->sortedBy(name).generateReferenceInitialization()/]
    [aClass.eOperations->sortedBy(name).generateOperationInitialization()/]
}
[/for]

void [packageName/]::initializePackageEDataTypes()
{
    [anEPackage.eAllContents(EDataType)->sortedBy(name).generateEDatatypeInitialization()/]
}
[/file]
[/template]
