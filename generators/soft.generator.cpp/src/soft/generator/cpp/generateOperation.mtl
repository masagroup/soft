[comment encoding = UTF-8 /]
[module generateOperation('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::generateType/]
[import soft::generator::cpp::generateCommon/]

[query private isPublic( anEOperation : EOperation, impl: Boolean ) : Boolean = anEOperation.getVisibilityType(impl) = 'public'/]

[template public generateOperationDeclaration(anEOperation : EOperation, impl: Boolean)  ? ( anEOperation.isPublic(impl) ) ]
virtual [anEOperation.generateReturnType()/] [anEOperation.name/]([anEOperation.generateParameterList()/])[if (hasKey('const'))] const[/if] [abstractSufix(impl)/];


[/template]


[template public generateOperationImplementation(anEOperation : EOperation) ? ( anEOperation.isPublic(true))]
[let className : String = anEOperation.eContainingClass.getImplementationName()]
[anEOperation.generateReturnType()/] [className/]::[anEOperation.name/]([anEOperation.generateParameterList()/])[if (hasKey('const'))] const[/if]
{
    // [protected ( className+ '::' + anEOperation.name)]
[if (hasKey('body'))]
    [valueKey('body')/]
[else]
    
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";
[/if]
    // [/protected]
}
[/let]
[/template]

[template public generateOperationMock(anEOperation : EOperation )  ? ( anEOperation.isPublic(false) ) ]
[let needExt : Boolean = anEOperation.eContainingClass.eOperations->select( eC | eC.name = anEOperation.name )->size() > 1]
MOCK_METHOD[if needExt]_EXT[/if]([anEOperation.name/] ,[anEOperation.eParameters->size()/][if needExt], [anEOperation.generateReturnType()/]([anEOperation.generateParameterList(false)/]), [anEOperation.getElementIdentifier()/][/if]) 
[/let]
[/template]

[template public generateStaticOperationID(aOperation : EOperation , aClass : EClass )]
/**
 * The operation id for the '[aOperation.name/]' operation.
 */
static const int [aClass.getOperationIDName(aOperation)/] = [aClass.getOperationValue(aOperation)/];

[/template]

[template public generateStaticOperationCountID(anEClass : EClass )]
/**
 *  The number of operations of the class [anEClass.name/].
 */
static const int [anEClass.getOperationCountID()/] = [anEClass.getOperationCountValue()/];

[/template]

[query public simpleDatatypeGetter(anEClassifier : EClassifier, anOperation: EOperation) : String = if anOperation.eType.oclIsUndefined() or anOperation.eTypeParameters->notEmpty() then 'nullptr' else needMetaModelPackageGetter(anEClassifier, anOperation.eContainingClass).concat('get').concat(anEClassifier.getElementAccessorName()).concat('()') endif/]

[template public generateOperationCreation(anEOperation : EOperation)]
[anEOperation.getElementInstanceName()/] = factory->createEOperation([anEOperation.eContainingClass.getElementInstanceName()/], [anEOperation.eContainingClass.getOperationIDName(anEOperation)/]);

[/template]

[template public generateOperationInitialization(anEOperation : EOperation)]
[anEOperation.getElementInstanceName()/]->setEType([anEOperation.eType.simpleDatatypeGetter(anEOperation)/]);
[anEOperation.getElementInstanceName()/]->setName("[anEOperation.name.toString()/]");
[anEOperation.getElementInstanceName()/]->setLowerBound([anEOperation.lowerBound/]);
[anEOperation.getElementInstanceName()/]->setUpperBound([anEOperation.upperBound/]);
[anEOperation.getElementInstanceName()/]->setUnique([anEOperation.unique.toString()/]);
[anEOperation.getElementInstanceName()/]->setOrdered([anEOperation.ordered.toString()/]);

[for (anEParameter : EParameter | anEOperation.eParameters) separator ('\r\n')]
{
	std::shared_ptr<ecore::EParameter> parameter = ecore::EcoreFactory::eInstance()->createEParameter([anEOperation.getElementInstanceName()/]);
	parameter->setName("[anEParameter.name/]");
	parameter->setEType([anEParameter.eType.simpleDatatypeGetter(anEParameter.eOperation)/]);
	parameter->setLowerBound(0);
	parameter->setUpperBound(1);
	parameter->setUnique(true);
	parameter->setOrdered(true);
}
[/for]

[/template]
