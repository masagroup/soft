[comment encoding = UTF-8 /]
[module generateReference('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::generateClass /]
[import soft::generator::cpp::generateType /]
[import soft::generator::cpp::generateCommon /]

[template public generateReferenceDeclaration(anEReference : EReference, impl : EBoolean) ]
[anEReference.generateReferenceGetterDeclaration(impl)/]
[anEReference.generateReferenceSetterDeclaration(impl)/]
[/template]

[template public generateReferenceMock(anEReference : EReference) ]
[anEReference.generateReferenceGetterMock()/]
[anEReference.generateReferenceSetterMock()/]
[/template]

[template public generateReferenceGetterDeclaration(anEReference : EReference, impl : EBoolean)? (hasGetter('public',impl))]
virtual [anEReference.generateReturnType()/] [anEReference.getGetterName()/]() const [abstractSufix(impl)/];

[/template]

[template public generateReferenceGetterMock(anEReference : EReference)? (hasGetter('public',false))]
MOCK_METHOD([anEReference.getGetterName()/],0);
[/template]


[template public generateReferenceSetterDeclaration(anEReference : EReference, impl : EBoolean) ? ( hasSetter('public',impl) )]
virtual void [anEReference.getSetterName()/]([if (not anEReference.eGenericType.oclIsKindOf(EDataType))]
[generateReferenceParameter(anEReference)/][else]
[anEReference.eGenericType.generateCppType()/][/if]
[anEReference.name/]) [abstractSufix(impl)/];


[/template]

[template public generateReferenceSetterMock(anEReference : EReference)? (hasSetter('public',false))]
MOCK_METHOD([anEReference.getSetterName()/],1);
[/template]

[template public generateReferenceParameter(anEReference : EReference)]
[if(anEReference.upperBound = 1)]
const [anEReference.eGenericType.generateCppType()/]& [anEReference.name/][else]
const std::shared_ptr<EList<[anEReference.eGenericType.generateCppType()/]> >& [anEReference.name/][/if]
[/template]

[template public generateReferenceProtected(anEReference : EReference) ]
[anEReference.generateReferenceType()/] [anEReference.name/]_;

[/template]

[template public generateReferenceCpp(anEReference : EReference)]
[anEReference.generateReferenceGetterCpp()/]

[anEReference.generateReferenceSetterCpp()/]
[/template]

[template public generateReferenceSetterCpp(anEReference : EReference) ? (hasSetter('public',true))]
[let className : String = anEReference.eContainingClass.getImplementationName()]
void [className/]::[anEReference.getSetterName()/]([generateReferenceParameter(anEReference)/])
{
    // [protected (className + '::' + anEReference.getSetterName())]
[if (hasKey('setterBody'))]
    [valueKey('setterBody')/] 
[else]
    [anEReference.name/]_ = [anEReference.name/];
[/if]
    // [/protected]
}
[/let]
[/template]

[template public generateReferenceGetterCpp(anEReference : EReference) ? (hasGetter('public',true) and anEReference.upperBound <> 1)]
[let className : String = anEReference.eContainingClass.getImplementationName()]
[anEReference.generateReturnType()/] [className/]::[anEReference.getGetterName()/]() const
{
    // [protected (className + '::' + anEReference.getGetterName())]
[if (hasKey('getterBody'))]
    [valueKey('getterBody')/]
[else]
    if ( ![anEReference.name/]_ )
        const_cast<[className/]*>(this)->[anEReference.name/]_.reset(new [getListConstructor()/]); 
    return [anEReference.name/]_;
[/if]
    // [/protected]
}
[/let]
[/template]

[template public generateReferenceGetterCpp(anEReference : EReference) ? (hasGetter('public',true))]
[let className : String = anEReference.eContainingClass.getImplementationName()]
[anEReference.generateReturnType()/] [className/]::[anEReference.getGetterName()/]() const
{
    // [protected (className + '::' + anEReference.getGetterName())]
[if (hasKey('getterBody'))]
    //generated from getterbody annotation
    [valueKey('getterBody')/]
    //end of body
[else][if(anEReference.lowerBound>0)]assert([anEReference.name/]_);[/if]
    return [anEReference.name/]_[if (anEReference.isBackReference())].lock()[/if];
[/if]
    // [/protected]
[/let]
}
[/template]

[template private getListConstructor( anEReference : EReference ) post(trim())]
[let typeArgument : String = anEReference.eGenericType.generateCppType()]
[let thisPtrGetterName : String = anEReference.eContainingClass.generateGetThisPtrPropertyGetterName()]
[let packageName : String = anEReference.getMetaModelPackageNameForEStructuralFeature(anEReference.eContainingClass)]
[let featureID : String = anEReference.eContainingClass.getFeatureIDName( anEReference )]
[if (anEReference.containment)]
    [if anEReference.eOpposite.oclIsUndefined() ]
        EObjectEList<[typeArgument/],true,true,false>([thisPtrGetterName/](), [packageName/]::[featureID/] )
    [else]
        [let reverseFeature :EReference = anEReference.eOpposite ]
        [let reversePackageName : String = reverseFeature.getMetaModelPackageNameForEStructuralFeature(reverseFeature.eContainingClass) ]
        [let reverseFeatureID :String = reverseFeature.eContainingClass.getFeatureIDName(reverseFeature) ]
        EObjectEList<[typeArgument/],true,true,true>( [thisPtrGetterName/](), [packageName/]::[featureID/] , [reversePackageName/]::[reverseFeatureID/])
        [/let]
        [/let]
        [/let]
    [/if]
[else]
    [if anEReference.eOpposite.oclIsUndefined() ]
        EObjectEList<[typeArgument/],false,false,false>( [thisPtrGetterName/](), [packageName/]::[featureID/])
    [else]
        [let reverseFeature :EReference = anEReference.eOpposite ]
        [let reversePackageName : String = reverseFeature.getMetaModelPackageNameForEStructuralFeature(reverseFeature.eContainingClass) ]
        [let reverseFeatureID :String = reverseFeature.eContainingClass.getFeatureIDName(reverseFeature) ]
        EObjectEList<[typeArgument/],false,true,true>( [thisPtrGetterName/](), [packageName/]::[featureID/] , [reversePackageName/]::[reverseFeatureID/])
        [/let]
        [/let]
        [/let]
    [/if]
[/if]
[/let]
[/let]
[/let]
[/let]
[/template]

[template public generateReferenceCreation(anEReference : EReference)]
[anEReference.getElementInstanceName()/] = factory->createEReference([anEReference.eContainingClass.getElementInstanceName()/], [anEReference.eContainingClass.getFeatureIDName(anEReference)/]);

[/template] 
 
[template public generateReferenceInitialization(anEReference : EReference)]
[anEReference.getElementInstanceName()/]->setName("[anEReference.name/]");
[anEReference.getElementInstanceName()/]->setEType([anEReference.eGenericType.eClassifier.packageGetter(anEReference)/]);
[anEReference.getElementInstanceName()/]->setLowerBound([anEReference.lowerBound/]);
[anEReference.getElementInstanceName()/]->setUpperBound([anEReference.upperBound/]);
[anEReference.getElementInstanceName()/]->setTransient([anEReference.transient.toString()/]);
[anEReference.getElementInstanceName()/]->setVolatile([anEReference.volatile.toString()/]);
[anEReference.getElementInstanceName()/]->setChangeable([anEReference.changeable.toString()/]);
[anEReference.getElementInstanceName()/]->setUnsettable([anEReference.unsettable.toString()/]);
[anEReference.getElementInstanceName()/]->setUnique([anEReference.unique.toString()/]);
[anEReference.getElementInstanceName()/]->setDerived([anEReference.derived.toString()/]);
[anEReference.getElementInstanceName()/]->setOrdered([anEReference.ordered.toString()/]);
[anEReference.getElementInstanceName()/]->setContainment([anEReference.containment.toString()/]);
[anEReference.getElementInstanceName()/]->setResolveProxies([anEReference.resolveProxies.toString()/]);
{
	std::string defaultValue = "[anEReference.defaultValueLiteral/]";
	if (!defaultValue.empty())
		[anEReference.getElementInstanceName()/]->setDefaultValueLiteral(defaultValue);

	std::shared_ptr<ecore::EReference>  otherEnd = [anEReference.eOpposite.getPackageGetter()/];
	if (otherEnd != nullptr)
   		[anEReference.getElementInstanceName()/]->setEOpposite(otherEnd);
}

[/template]
