[comment encoding = UTF-8 /]
[module generateImplementationHeader('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::generateAttribute /]
[import soft::generator::cpp::generateClass /]
[import soft::generator::cpp::generateOperation /]
[import soft::generator::cpp::generateReference /]
[import soft::generator::cpp::generateStructuralFeature /]
[import soft::generator::cpp::generateType /]
[import soft::generator::cpp::utils /]

[template public generateImplementationHeader(aClass : EClass){ className : String = aClass.name.toUpperFirst().concat('Impl'); guardName : String = '_'.concat(className); }]
[file ('src-gen/'.concat(aClass.ePackage.name).concat('/impl/').concat(className).concat('.hpp'), false, 'UTF-8')]
[startGuard(guardName)/]

//*********************************
// generated Includes

//Model includes
#include "[aClass.ePackage.name/]/[aClass.name.toUpperFirst().concat('.hpp')/]"

[for (aEClass : EClass | aClass.eSuperTypes->asOrderedSet()->sortedBy(name)) separator ('\n')]
#include "[aEClass.ePackage.name/]/impl/[aEClass.name.toUpperFirst()/]Impl.hpp"[/for]

[if (not(aClass.name='EObject') and (aClass.eSuperTypes->isEmpty()))]
#include "ecore/impl/EObjectImpl.hpp"
[/if]

//*********************************
[comment namespace /]
namespace [aClass.ePackage.name/] 
{
    class [className/] :[for (sClass : EClass | aClass.eSuperTypes->asOrderedSet()->sortedBy(name)) separator (', ') after (', ')]
virtual public [getClassWithNamespace(aClass, sClass)/]Impl[/for][if (aClass.eSuperTypes->isEmpty())]
[if (not(aClass.name='EObject'))]virtual public ecore::EObjectImpl,[/if]
[/if]virtual public [aClass.name.toUpperFirst()/] 
    {
        public: 
            [className/](const [className/] & obj);
            virtual std::shared_ptr<ecore::EObject> copy() const;

        private:    
            [className/]& operator=([className/] const&) = delete;

        protected:
            friend class [aClass.ePackage.name.concat('FactoryImpl').toUpperFirst()/];
            [className/]();
            [aClass.generateGetThisPtr()/]

            [let ref:OrderedSet(EReference) = aClass.getAllContainers()]
            [for(aReference:EReference | ref->sortedBy(name)) ]
            //Additional constructors for the containments back reference
                [if(ref->select(eType.name = aReference.eType.name)->size()>1 )]
                    [if(ref->select(eType.name = aReference.eType.name)->asOrderedSet()->sortedBy(name)->first() = aReference)]
            [className/]([aReference.generateReferenceType(true)/] par_[aReference.eType.name/], const int reference_id);
                    [/if]
                [else]
            [className/]([aReference.generateReferenceType(true)/] par_[aReference.name/]);
                [/if]


            [/for]
            [/let]


        public:
            //destructor
            virtual ~[className/]();
            
            [if(aClass.eOperations->notEmpty())]

            //*********************************
            // Operations
            //*********************************
            [aClass.eOperations->sortedBy(name).generateOperationDeclaration(true)/]
            [/if]
            [if(aClass.eAttributes->notEmpty())]

            //*********************************
            // Attributes Getter Setter
            //*********************************
            [aClass.eAttributes->sortedBy(name).generateAttributeDeclaration(true)/]
            [/if]
            [if(aClass.eReferences->notEmpty())]

            //*********************************
            // References
            //*********************************
            [aClass.eReferences->sortedBy(name).generateReferenceDeclaration(true)/]
            [/if]
            
            //*********************************
            // Structural Feature Getter/Setter
            //*********************************
            [aClass.generateEContainerOperation(true)/] 
            
            
        protected:
            virtual std::shared_ptr<[needNamespace(aClass.ePackage, 'EClass')/]> eStaticClass() const;
            [aClass.generateGetDel(true)/]
            [aClass.generateIsSetDel(true)/]
            [aClass.generateSetDel(true)/]

        protected:
            [if(aClass.eAttributes->notEmpty())]
            //*********************************
            // Attribute Members
            //*********************************
            [aClass.eAttributes->sortedBy(name).generateAttributeProtected()/]
            [/if]
            [if(aClass.eReferences->notEmpty())]
            //*********************************
            // Reference Members
            //*********************************
            [aClass.eReferences->sortedBy(name).generateReferenceProtected()/]
            [/if]

        private:
            std::weak_ptr<[aClass.name.toUpperFirst()/]> [generateGetThisPtrPropertyName()/]_;
    };
}
[endGuard(guardName)/]
[/file]
[/template]