// *****************************************************************************
//
// This file is part of a MASA library or program.
// Refer to the included end-user license agreement for restrictions.
//
// Copyright (c) 2018 MASA Group
//
// *****************************************************************************

// *****************************************************************************
//    
// Warning: This file was generated by sof.generator.cpp Generator
// 
//*****************************************************************************
#include "ecore/impl/EClassifierImpl.hpp"
#include "ecore/EAnnotation.hpp"
#include "ecore/EAttribute.hpp"
#include "ecore/EClass.hpp"
#include "ecore/ENamedElement.hpp"
#include "ecore/EPackage.hpp"
#include "ecore/EStructuralFeature.hpp"
#include "ecore/ETypeParameter.hpp"
#include "ecore/EcoreFactory.hpp"
#include "ecore/EcorePackage.hpp"
#include "ecore/impl/EObjectEList.hpp"
#include "ecore/EList.hpp"


#include <cassert>
#include <iostream>
#include <sstream>

//Start of user code EClassifierImpl [declaration-includes]
//End of user code


using namespace ecore;
using namespace ecore::impl;

//Start of user code EClassifierImpl [declaration-begin]
//End of user code

//*********************************
// Constructor / Destructor
//*********************************
EClassifierImpl::EClassifierImpl()
:   ePackage_()
,   eTypeParameters_([&](){ return initETypeParameters();})
,   classifierID_([&](){ return initClassifierID();})
//Start of user code EClassifierImpl::EClassifierImpl
{
}
//End of user code


EClassifierImpl::~EClassifierImpl()
{
//Start of user code EClassifierImpl::~EClassifierImpl
//End of user code
}


std::shared_ptr<EClass> EClassifierImpl::eStaticClass() const
{
    return EcorePackage::eInstance()->getEClassifier();
}

std::shared_ptr<EClassifierImpl> EClassifierImpl::getThisPtr() const
{
    return thisPtr_.lock();
}

void EClassifierImpl::setThisPtr(const std::shared_ptr<EClassifierImpl>& thisPtr)
{
    thisPtr_ = thisPtr;
    ENamedElementImpl::setThisPtr(thisPtr);
}

//*********************************
// Attributes
//*********************************
const boost::any& EClassifierImpl::getDefaultValue() const 
{
    // Start of user code EClassifierImpl::getDefaultValue
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";
    // End of user code
}


int EClassifierImpl::getClassifierID() const 
{
    // Start of user code EClassifierImpl::getClassifierID
    return classifierID_.get();
    // End of user code
}


void EClassifierImpl::setClassifierID(int newClassifierID)
{
    // Start of user code EClassifierImpl::setClassifierID
    auto oldClassifierID = classifierID_.get();
    classifierID_ = newClassifierID;
    if ( eNotificationRequired() )
        eNotify( std::make_shared<Notification>(getThisPtr(), Notification::SET, EcorePackage::ECLASSIFIER__CLASSIFIER_ID, oldClassifierID, newClassifierID));
    // End of user code
}



//*********************************
// References
//*********************************
std::shared_ptr<ecore::EPackage> EClassifierImpl::getEPackage() const 
{
    // Start of user code EClassifierImpl::getEPackage
    if ( eContainerFeatureID() != EcorePackage::ECLASSIFIER__EPACKAGE )
        return std::shared_ptr<ecore::EPackage>();
    else
        return std::dynamic_pointer_cast<ecore::EPackage>(eContainer());
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::ETypeParameter>>> EClassifierImpl::getETypeParameters() const 
{
    // Start of user code EClassifierImpl::getETypeParameters
    return eTypeParameters_.get();
    // End of user code
}




//*********************************
// Reflectives
//*********************************
boost::any EClassifierImpl::eGet(int featureID, bool resolve, bool coreType) const
{
    switch(featureID)
    {
        case EcorePackage::ECLASSIFIER__CLASSIFIER_ID:
            return getClassifierID();
        case EcorePackage::ECLASSIFIER__DEFAULT_VALUE:
            return getDefaultValue();
        case EcorePackage::ECLASSIFIER__EPACKAGE:
            return getEPackage();
        case EcorePackage::ECLASSIFIER__ETYPE_PARAMETERS:
            return getETypeParameters();
    }
    return ENamedElementImpl::eGet(featureID, resolve, coreType);
}


void EClassifierImpl::eSet(int featureID, const boost::any& newValue)
{
    switch(featureID)
    {
        case EcorePackage::ECLASSIFIER__CLASSIFIER_ID:
        {
            int c = boost::any_cast<int>(newValue);
            setClassifierID(c);
            return;
        }
        case EcorePackage::ECLASSIFIER__ETYPE_PARAMETERS:
        {
            std::shared_ptr<EList<std::shared_ptr<ecore::ETypeParameter>>> e = boost::any_cast<std::shared_ptr<EList<std::shared_ptr<ecore::ETypeParameter>>>>(newValue);
            getETypeParameters()->clear();
            getETypeParameters()->addAll(*e);
            return;
        }
    }
    return ENamedElementImpl::eSet(featureID, newValue);
}

void EClassifierImpl::eUnset(int featureID)
{
    switch(featureID)
    {
        case EcorePackage::ECLASSIFIER__CLASSIFIER_ID:
        {
            setClassifierID( -1 ); 
            return;
        }
        case EcorePackage::ECLASSIFIER__ETYPE_PARAMETERS:
        {
            getETypeParameters()->clear();
            return;
        }
    }
    return ENamedElementImpl::eUnset(featureID);
}


template <typename T>
bool is_uninitialized(std::weak_ptr<T> const& weak) {
    using wt = std::weak_ptr<T>;
    return !weak.owner_before(wt{}) && !wt{}.owner_before(weak);
}

bool EClassifierImpl::eIsSet(int featureID) const
{
    switch(featureID)
    {
        case EcorePackage::ECLASSIFIER__CLASSIFIER_ID:
            return classifierID_ != -1;
        case EcorePackage::ECLASSIFIER__DEFAULT_VALUE:
            return !getDefaultValue().empty();
        case EcorePackage::ECLASSIFIER__EPACKAGE:
            return !is_uninitialized(ePackage_);
        case EcorePackage::ECLASSIFIER__ETYPE_PARAMETERS:
            return eTypeParameters_ && !eTypeParameters_->empty();
    }
    return ENamedElementImpl::eIsSet(featureID);
}

std::shared_ptr<ENotificationChain> EClassifierImpl::eBasicInverseAdd( const std::shared_ptr<EObject>& otherEnd, int featureID, const std::shared_ptr<ENotificationChain>& notifications )
{
    // Start of user code EClassifierImpl::eBasicInverseAdd
    switch( featureID )
    {
        case EcorePackage::ECLASSIFIER__EPACKAGE:
        {
            auto msgs = notifications;
            if (eContainer())
                msgs = eBasicRemoveFromContainer(msgs);
            return eBasicSetContainer( otherEnd , EcorePackage::ECLASSIFIER__EPACKAGE, msgs );
        }
    }
    return ENamedElementImpl::eBasicInverseAdd(otherEnd, featureID, notifications);
    // End of user code
}


std::shared_ptr<ENotificationChain> EClassifierImpl::eBasicInverseRemove( const std::shared_ptr<EObject>& otherEnd, int featureID, const std::shared_ptr<ENotificationChain>& notifications )
{
    // Start of user code EClassifierImpl::eBasicInverseRemove
    switch( featureID )
    {
        case EcorePackage::ECLASSIFIER__EPACKAGE:
        {
            return eBasicSetContainer( nullptr , EcorePackage::ECLASSIFIER__EPACKAGE, notifications );
        }
        case EcorePackage::ECLASSIFIER__ETYPE_PARAMETERS:
        {
            auto list = std::dynamic_pointer_cast<ENotifyingList<std::shared_ptr<EObject>>>( getETypeParameters() );
            _ASSERTE(list);
            return list->remove( otherEnd , notifications );
        }
    }
    return ENamedElementImpl::eBasicInverseRemove(otherEnd, featureID, notifications);
    // End of user code
}



//*********************************
// Initializations
//*********************************
std::shared_ptr<EList<std::shared_ptr<ecore::ETypeParameter>>> EClassifierImpl::initETypeParameters()
{
    // Start of user code EClassifierImpl::initETypeParameters
    return std::make_shared<EObjectEList<std::shared_ptr<ecore::ETypeParameter>,true,true,false,false,false>>(thisPtr_, EcorePackage::ECLASSIFIER__ETYPE_PARAMETERS );
    // End of user code
}

int EClassifierImpl::initClassifierID()
{
    // Start of user code EClassifierImpl::initClassifierID
    return getEPackage() ? static_cast<int>( getEPackage()->getEClassifiers()->indexOf( getThisPtr() ) ): -1;
    // End of user code
}




// Start of user code EClassifierImpl [declaration-end]
// End of user code

