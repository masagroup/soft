// *****************************************************************************
//
// This file is part of a MASA library or program.
// Refer to the included end-user license agreement for restrictions.
//
// Copyright (c) 2018 MASA Group
//
// *****************************************************************************

// *****************************************************************************
//    
// Warning: This file was generated by sof.generator.cpp Generator
// 
//*****************************************************************************
#include "ecore/impl/EClassImpl.hpp"
#include "ecore/EAnnotation.hpp"
#include "ecore/EAttribute.hpp"
#include "ecore/EClass.hpp"
#include "ecore/EClassifier.hpp"
#include "ecore/EGenericType.hpp"
#include "ecore/EOperation.hpp"
#include "ecore/EPackage.hpp"
#include "ecore/EReference.hpp"
#include "ecore/EStructuralFeature.hpp"
#include "ecore/ETypeParameter.hpp"
#include "ecore/EcoreFactory.hpp"
#include "ecore/EcorePackage.hpp"
#include "ecore/impl/EObjectEList.hpp"
#include "ecore/EList.hpp"


#include <cassert>
#include <iostream>
#include <sstream>

//Start of user code EClassImpl [declaration-includes]
#include "ecore/EcorePackage.hpp"
#include "ecore/EAdapter.hpp"
#include "ecore/impl/EOperationImpl.hpp"
#include "ecore/impl/EStructuralFeatureImpl.hpp"
//End of user code


using namespace ecore;
using namespace ecore::impl;

//Start of user code EClassImpl [declaration-begin]
class EClassImpl::ESuperAdapter : public EAdapter
{
public:
    ESuperAdapter( EClassImpl& eClassImpl )
        : eClassImpl_( eClassImpl )
        , subClasses_()
    {
    }

    virtual ~ESuperAdapter()
    {

    }

    std::vector<std::weak_ptr<EClassImpl>>& getSubClasses()
    {
        return subClasses_;
    }

    virtual void notifyChanged( const std::shared_ptr<ENotification>& notification )
    {
        int eventType = notification->getEventType();
        auto eNotifier = std::dynamic_pointer_cast<EClassImpl>( notification->getNotifier() );
        if( eventType != ENotification::REMOVING_ADAPTER )
        {
            int featureID = notification->getFeatureID();
            if( featureID == EcorePackage::ECLASS__ESUPER_TYPES )
            {
                switch( eventType )
                {
                    case ENotification::SET:
                    case ENotification::RESOLVE:
                    {
                        boost::any oldValue = notification->getOldValue();
                        if( !oldValue.empty() )
                        {
                            auto eClass = boost::any_cast<std::shared_ptr<EClass>>( oldValue );
                            auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                            auto& subClasses = eClassImpl->eSuperAdapter_->getSubClasses();
                            auto it = std::find_if( subClasses.begin(), subClasses.end(), [=]( const auto& w ) { return w.lock() = eNotifier; } );
                            if ( it != subClasses.end() )
                                subClasses.erase( it );
                        }
                        boost::any newValue = notification->getNewValue();
                        if( !newValue.empty() )
                        {
                            auto eClass = boost::any_cast<std::shared_ptr<EClass>>( newValue );
                            auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                            auto& subClasses = eClassImpl->eSuperAdapter_->getSubClasses();
                            subClasses.push_back( eNotifier );
                        }
                        break;
                    }
                    case ENotification::ADD:
                    {
                        boost::any newValue = notification->getNewValue();
                        if( !newValue.empty() )
                        {
                            auto eClass = boost::any_cast<std::shared_ptr<EClass>>( newValue );
                            auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                            auto& subClasses = eClassImpl->eSuperAdapter_->getSubClasses();
                            subClasses.push_back( eNotifier );
                        }
                        break;
                    }
                    case ENotification::ADD_MANY:
                    {
                        boost::any newValue = notification->getNewValue();
                        if( !newValue.empty() )
                        {
                            auto eCollection = boost::any_cast<std::shared_ptr<EList<std::shared_ptr<EClass>>>>( newValue );
                            for( const auto& eClass : *eCollection )
                            {
                                auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                                auto& subClasses = eClassImpl->eSuperAdapter_->getSubClasses();
                                subClasses.push_back( eNotifier );
                            }
                        }
                        break;
                    }
                    case ENotification::REMOVE:
                    {
                        boost::any oldValue = notification->getOldValue();
                        if( !oldValue.empty() )
                        {
                            auto eClass = boost::any_cast<std::shared_ptr<EClass>>( oldValue );
                            auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                            auto& subClasses = eClassImpl->eSuperAdapter_->getSubClasses();
                            auto it = std::find_if( subClasses.begin(), subClasses.end(), [=]( const auto& w ) { return w.lock() = eNotifier; } );
                            if (it != subClasses.end())
                                subClasses.erase( it );
                        }
                        break;
                    }
                    case ENotification::REMOVE_MANY:
                    {
                        boost::any oldValue = notification->getOldValue();
                        if( !oldValue.empty() )
                        {
                            auto eCollection = boost::any_cast<std::shared_ptr<EList<std::shared_ptr<EClass>>>>( oldValue );
                            for( const auto& eClass : *eCollection )
                            {
                                auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                                auto& subClasses = eClassImpl->eSuperAdapter_->getSubClasses();
                                auto it = std::find_if( subClasses.begin(), subClasses.end(), [=]( const auto& w ) { return w.lock() = eNotifier; } );
                                if (it != subClasses.end())
                                    subClasses.erase( it );
                            }
                        }
                        break;
                    }
                }
            }
            eClassImpl_.setModified( featureID );
        }
    }

private:
    EClassImpl& eClassImpl_;
    std::vector<std::weak_ptr<EClassImpl>> subClasses_;
};
//End of user code

//*********************************
// Constructor / Destructor
//*********************************
EClassImpl::EClassImpl()
:   abstract_(false)
,   interface_(false)
,   eSuperTypes_([&](){ return initESuperTypes();})
,   eOperations_([&](){ return initEOperations();})
,   eAllAttributes_([&](){ initEAllAttributes();})
,   eAllReferences_([&](){ initEAllReferences();})
,   eReferences_([&](){ initEReferences();})
,   eAttributes_([&](){ initEAttributes();})
,   eAllContainments_([&](){ initEAllContainments();})
,   eAllOperations_([&](){ initEAllOperations();})
,   eAllStructuralFeatures_([&](){ initEAllStructuralFeatures();})
,   eAllSuperTypes_([&](){ initEAllSuperTypes();})
,   eIDAttribute_([&](){ initEIDAttribute();})
,   eStructuralFeatures_([&](){ return initEStructuralFeatures();})
,   eGenericSuperTypes_([&](){ initEGenericSuperTypes();})
,   eAllGenericSuperTypes_([&](){ initEAllGenericSuperTypes();})
//Start of user code EClassImpl::EClassImpl
,   eSuperAdapter_( new ESuperAdapter( *this ) )
{
    eAdapters().add( eSuperAdapter_.get() );
}
//End of user code


EClassImpl::~EClassImpl()
{
#ifdef SHOW_DELETION
    std::string name;
    if ( auto named = dynamic_cast<ENamedElement*>( this ) )
        name = named->getName();
    std::cout << "delete EClass ["<< this << "] " << name << std::endl;
#endif
//Start of user code EClassImpl::~EClassImpl
    eAdapters().remove( eSuperAdapter_.get() );
//End of user code
}


std::shared_ptr<EClass> EClassImpl::eStaticClass() const
{
    return EcorePackage::eInstance()->getEClass();
}

std::shared_ptr<EClassImpl> EClassImpl::getThisPtr() const
{
    return thisPtr_.lock();
}

void EClassImpl::setThisPtr(const std::shared_ptr<EClassImpl>& thisPtr)
{
    thisPtr_ = thisPtr;
    EClassifierImpl::setThisPtr(thisPtr);
}

//*********************************
// Operations
//*********************************
bool EClassImpl::isSuperTypeOf(const std::shared_ptr<ecore::EClass>& someClass)
{
    // Start of user code EClassImpl::isSuperTypeOf
    return someClass == getThisPtr() || someClass->getEAllSuperTypes()->contains( getThisPtr() );
    // End of user code
}
int EClassImpl::getFeatureCount()
{
    // Start of user code EClassImpl::getFeatureCount
    return static_cast<int>( getEAllStructuralFeatures()->size() );
    // End of user code
}
std::shared_ptr<ecore::EStructuralFeature> EClassImpl::getEStructuralFeature(int featureID)
{
    // Start of user code EClassImpl::getEStructuralFeature_EInt
    auto features = getEAllStructuralFeatures();
    return featureID >= 0 && featureID < features->size() ? features->get( featureID ) : std::shared_ptr<EStructuralFeature>();
    // End of user code
}
std::shared_ptr<ecore::EStructuralFeature> EClassImpl::getEStructuralFeature(const std::string& featureName)
{
    // Start of user code EClassImpl::getEStructuralFeature_EString
    initNameToFeatureMap();
    auto it = nameToFeatureMap_->find( featureName );
    return it != nameToFeatureMap_->end() ? it->second : std::shared_ptr<EStructuralFeature>();
    // End of user code
}
int EClassImpl::getFeatureID(const std::shared_ptr<ecore::EStructuralFeature>& feature)
{
    // Start of user code EClassImpl::getFeatureID
    auto features = getEAllStructuralFeatures();
    int featureID = feature->getFeatureID();
    if (featureID != -1)
    {
        for (; featureID < features->size(); ++featureID)
        {
            if (features->get( featureID ) == feature)
                return featureID;
        }
    }
    return -1;
    // End of user code
}
int EClassImpl::getOperationCount()
{
    // Start of user code EClassImpl::getOperationCount
    return static_cast<int>( getEAllOperations()->size() );
    // End of user code
}
std::shared_ptr<ecore::EOperation> EClassImpl::getEOperation(int operationID)
{
    // Start of user code EClassImpl::getEOperation
    auto operations = getEAllOperations();
    return operationID >= 0 && operationID < operations->size() ? operations->get( operationID ) : std::shared_ptr<EOperation>();
    // End of user code
}
int EClassImpl::getOperationID(const std::shared_ptr<ecore::EOperation>& operation)
{
    // Start of user code EClassImpl::getOperationID
    auto operations = getEAllOperations();
    int operationID = operation->getOperationID();
    if (operationID != -1)
    {
        for (; operationID < operations->size(); ++operationID)
        {
            if (operations->get( operationID ) == operation)
                return operationID;
        }
    }
    return -1;
    // End of user code
}
std::shared_ptr<ecore::EOperation> EClassImpl::getOverride(const std::shared_ptr<ecore::EOperation>& operation)
{
    // Start of user code EClassImpl::getOverride
    initOperationToOverrideMap();
    auto it = operationToOverrideMap_->find( operation );
    return it != operationToOverrideMap_->end() ? it->second : std::shared_ptr<EOperation>();
    // End of user code
}
std::shared_ptr<ecore::EGenericType> EClassImpl::getFeatureType(const std::shared_ptr<ecore::EStructuralFeature>& feature)
{
    // Start of user code EClassImpl::getFeatureType
    std::cout << BOOST_CURRENT_FUNCTION << std::endl;
    throw "NotImplementedException";
    // End of user code
}

//*********************************
// Attributes
//*********************************
bool EClassImpl::isAbstract() const 
{
    // Start of user code EClassImpl::isAbstract
    return abstract_;
    // End of user code
}


void EClassImpl::setAbstract(bool newAbstract)
{
    // Start of user code EClassImpl::setAbstract
    abstract_ = newAbstract;
    // End of user code
}


bool EClassImpl::isInterface() const 
{
    // Start of user code EClassImpl::isInterface
    return interface_;
    // End of user code
}


void EClassImpl::setInterface(bool newInterface)
{
    // Start of user code EClassImpl::setInterface
    interface_ = newInterface;
    // End of user code
}



//*********************************
// References
//*********************************
std::shared_ptr<EList<std::shared_ptr<ecore::EClass>>> EClassImpl::getESuperTypes() const 
{
    // Start of user code EClassImpl::getESuperTypes
    return eSuperTypes_.get();
    // End of user code
}


void EClassImpl::unsetESuperTypes()
{
    // Start of user code EClassImpl::unsetESuperTypes
    if (eSuperTypes_)
        eSuperTypes_->clear();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EOperation>>> EClassImpl::getEOperations() const 
{
    // Start of user code EClassImpl::getEOperations
    return eOperations_.get();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EAttribute>>> EClassImpl::getEAllAttributes() const 
{
    // Start of user code EClassImpl::getEAllAttributes
    return eAllAttributes_.get();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EReference>>> EClassImpl::getEAllReferences() const 
{
    // Start of user code EClassImpl::getEAllReferences
    return eAllReferences_.get();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EReference>>> EClassImpl::getEReferences() const 
{
    // Start of user code EClassImpl::getEReferences
    return eReferences_.get();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EAttribute>>> EClassImpl::getEAttributes() const 
{
    // Start of user code EClassImpl::getEAttributes
    return eAttributes_.get();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EReference>>> EClassImpl::getEAllContainments() const 
{
    // Start of user code EClassImpl::getEAllContainments
    return eAllContainments_.get();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EOperation>>> EClassImpl::getEAllOperations() const 
{
    // Start of user code EClassImpl::getEAllOperations
    return eAllOperations_.get();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EStructuralFeature>>> EClassImpl::getEAllStructuralFeatures() const 
{
    // Start of user code EClassImpl::getEAllStructuralFeatures
    return eAllStructuralFeatures_.get();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EClass>>> EClassImpl::getEAllSuperTypes() const 
{
    // Start of user code EClassImpl::getEAllSuperTypes
    return eAllSuperTypes_.get();
    // End of user code
}


std::shared_ptr<ecore::EAttribute> EClassImpl::getEIDAttribute() const 
{
    // Start of user code EClassImpl::getEIDAttribute
    return eIDAttribute_.get();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EStructuralFeature>>> EClassImpl::getEStructuralFeatures() const 
{
    // Start of user code EClassImpl::getEStructuralFeatures
    return eStructuralFeatures_.get();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EGenericType>>> EClassImpl::getEGenericSuperTypes() const 
{
    // Start of user code EClassImpl::getEGenericSuperTypes
    return eGenericSuperTypes_.get();
    // End of user code
}


void EClassImpl::unsetEGenericSuperTypes()
{
    // Start of user code EClassImpl::unsetEGenericSuperTypes
    if (eGenericSuperTypes_)
        eGenericSuperTypes_->clear();
    // End of user code
}


std::shared_ptr<EList<std::shared_ptr<ecore::EGenericType>>> EClassImpl::getEAllGenericSuperTypes() const 
{
    // Start of user code EClassImpl::getEAllGenericSuperTypes
    return eAllGenericSuperTypes_.get();
    // End of user code
}




//*********************************
// Reflectives
//*********************************
boost::any EClassImpl::eGet(int featureID, bool resolve, bool coreType) const
{
    switch(featureID)
    {
        case EcorePackage::ECLASS__ABSTRACT:
            return isAbstract();
        case EcorePackage::ECLASS__EALL_ATTRIBUTES:
            return getEAllAttributes();
        case EcorePackage::ECLASS__EALL_CONTAINMENTS:
            return getEAllContainments();
        case EcorePackage::ECLASS__EALL_GENERIC_SUPER_TYPES:
            return getEAllGenericSuperTypes();
        case EcorePackage::ECLASS__EALL_OPERATIONS:
            return getEAllOperations();
        case EcorePackage::ECLASS__EALL_REFERENCES:
            return getEAllReferences();
        case EcorePackage::ECLASS__EALL_STRUCTURAL_FEATURES:
            return getEAllStructuralFeatures();
        case EcorePackage::ECLASS__EALL_SUPER_TYPES:
            return getEAllSuperTypes();
        case EcorePackage::ECLASS__EATTRIBUTES:
            return getEAttributes();
        case EcorePackage::ECLASS__EGENERIC_SUPER_TYPES:
            return getEGenericSuperTypes();
        case EcorePackage::ECLASS__EID_ATTRIBUTE:
            return getEIDAttribute();
        case EcorePackage::ECLASS__EOPERATIONS:
            return getEOperations();
        case EcorePackage::ECLASS__EREFERENCES:
            return getEReferences();
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
            return getEStructuralFeatures();
        case EcorePackage::ECLASS__ESUPER_TYPES:
            return getESuperTypes();
        case EcorePackage::ECLASS__INTERFACE:
            return isInterface();
    }
    return EClassifierImpl::eGet(featureID, resolve, coreType);
}


void EClassImpl::eSet(int featureID, const boost::any& newValue)
{
    switch(featureID)
    {
        case EcorePackage::ECLASS__ABSTRACT:
        {
            bool a = boost::any_cast<bool>(newValue);
            setAbstract(a);
            return;
        }
        case EcorePackage::ECLASS__EGENERIC_SUPER_TYPES:
        {
            std::shared_ptr<EList<std::shared_ptr<ecore::EGenericType>>> e = boost::any_cast<std::shared_ptr<EList<std::shared_ptr<ecore::EGenericType>>>>(newValue);
            getEGenericSuperTypes()->clear();
            getEGenericSuperTypes()->addAll(*e);
            return;
        }
        case EcorePackage::ECLASS__EOPERATIONS:
        {
            std::shared_ptr<EList<std::shared_ptr<ecore::EOperation>>> e = boost::any_cast<std::shared_ptr<EList<std::shared_ptr<ecore::EOperation>>>>(newValue);
            getEOperations()->clear();
            getEOperations()->addAll(*e);
            return;
        }
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
        {
            std::shared_ptr<EList<std::shared_ptr<ecore::EStructuralFeature>>> e = boost::any_cast<std::shared_ptr<EList<std::shared_ptr<ecore::EStructuralFeature>>>>(newValue);
            getEStructuralFeatures()->clear();
            getEStructuralFeatures()->addAll(*e);
            return;
        }
        case EcorePackage::ECLASS__ESUPER_TYPES:
        {
            std::shared_ptr<EList<std::shared_ptr<ecore::EClass>>> e = boost::any_cast<std::shared_ptr<EList<std::shared_ptr<ecore::EClass>>>>(newValue);
            getESuperTypes()->clear();
            getESuperTypes()->addAll(*e);
            return;
        }
        case EcorePackage::ECLASS__INTERFACE:
        {
            bool i = boost::any_cast<bool>(newValue);
            setInterface(i);
            return;
        }
    }
    return EClassifierImpl::eSet(featureID, newValue);
}

void EClassImpl::eUnset(int featureID)
{
    switch(featureID)
    {
        case EcorePackage::ECLASS__ABSTRACT:
        {
            setAbstract( false ); 
            return;
        }
        case EcorePackage::ECLASS__EGENERIC_SUPER_TYPES:
        {
            unsetEGenericSuperTypes();
            return;
        }
        case EcorePackage::ECLASS__EOPERATIONS:
        {
            getEOperations()->clear();
            return;
        }
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
        {
            getEStructuralFeatures()->clear();
            return;
        }
        case EcorePackage::ECLASS__ESUPER_TYPES:
        {
            unsetESuperTypes();
            return;
        }
        case EcorePackage::ECLASS__INTERFACE:
        {
            setInterface( false ); 
            return;
        }
    }
    return EClassifierImpl::eUnset(featureID);
}


bool EClassImpl::eIsSet(int featureID) const
{
    switch(featureID)
    {
        case EcorePackage::ECLASS__ABSTRACT:
            return abstract_ != false;
        case EcorePackage::ECLASS__EALL_ATTRIBUTES:
            return eAllAttributes_ && !eAllAttributes_->empty();
        case EcorePackage::ECLASS__EALL_CONTAINMENTS:
            return eAllContainments_ && !eAllContainments_->empty();
        case EcorePackage::ECLASS__EALL_GENERIC_SUPER_TYPES:
            return eAllGenericSuperTypes_ && !eAllGenericSuperTypes_->empty();
        case EcorePackage::ECLASS__EALL_OPERATIONS:
            return eAllOperations_ && !eAllOperations_->empty();
        case EcorePackage::ECLASS__EALL_REFERENCES:
            return eAllReferences_ && !eAllReferences_->empty();
        case EcorePackage::ECLASS__EALL_STRUCTURAL_FEATURES:
            return eAllStructuralFeatures_ && !eAllStructuralFeatures_->empty();
        case EcorePackage::ECLASS__EALL_SUPER_TYPES:
            return eAllSuperTypes_ && !eAllSuperTypes_->empty();
        case EcorePackage::ECLASS__EATTRIBUTES:
            return eAttributes_ && !eAttributes_->empty();
        case EcorePackage::ECLASS__EGENERIC_SUPER_TYPES:
            return eGenericSuperTypes_ && !eGenericSuperTypes_->empty();
        case EcorePackage::ECLASS__EID_ATTRIBUTE:
            return eIDAttribute_ != nullptr;
        case EcorePackage::ECLASS__EOPERATIONS:
            return eOperations_ && !eOperations_->empty();
        case EcorePackage::ECLASS__EREFERENCES:
            return eReferences_ && !eReferences_->empty();
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
            return eStructuralFeatures_ && !eStructuralFeatures_->empty();
        case EcorePackage::ECLASS__ESUPER_TYPES:
            return eSuperTypes_ && !eSuperTypes_->empty();
        case EcorePackage::ECLASS__INTERFACE:
            return interface_ != false;
    }
    return EClassifierImpl::eIsSet(featureID);
}

boost::any EClassImpl::eInvoke(int operationID, const std::shared_ptr<EList<boost::any>>& arguments)
{
    // Start of user code EClassImpl::eInvoke
    switch( operationID )
    {
        case EcorePackage::ECLASS__GET_EOPERATION_EINT:
        {
            return getEOperation( boost::any_cast<int>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_ESTRUCTURAL_FEATURE_EINT:
        {
            return getEStructuralFeature( boost::any_cast<int>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_ESTRUCTURAL_FEATURE_ESTRING:
        {
            return getEStructuralFeature( boost::any_cast<std::string>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_FEATURE_COUNT:
        {
            return getFeatureCount();
        }
        case EcorePackage::ECLASS__GET_FEATURE_ID_ESTRUCTURALFEATURE:
        {
            return getFeatureID( boost::any_cast<std::shared_ptr<EStructuralFeature>>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_FEATURE_TYPE_ESTRUCTURALFEATURE:
        {
            return getFeatureType( boost::any_cast<std::shared_ptr<EStructuralFeature>>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_OPERATION_COUNT:
        {
            return getOperationCount();
        }
        case EcorePackage::ECLASS__GET_OPERATION_ID_EOPERATION:
        {
            return getOperationID( boost::any_cast<std::shared_ptr<EOperation>>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_OVERRIDE_EOPERATION:
        {
            return getOverride( boost::any_cast<std::shared_ptr<EOperation>>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__IS_SUPER_TYPE_OF_ECLASS:
        {
            return isSuperTypeOf( boost::any_cast<std::shared_ptr<EClass>>( arguments->get( 0 ) ) );
        }
    }
    return boost::any();
    // End of user code
}


std::shared_ptr<ENotificationChain> EClassImpl::eBasicInverseAdd( const std::shared_ptr<EObject>& otherEnd, int featureID, const std::shared_ptr<ENotificationChain>& notifications )
{
    // Start of user code EClassImpl::eBasicInverseAdd
    switch( featureID )
    {
        case EcorePackage::ECLASS__EOPERATIONS:
        {
            auto list = std::dynamic_pointer_cast<ENotifyingList<std::shared_ptr<EObject>>>( getEOperations() );
            _ASSERTE(list);
            return list->add( otherEnd , notifications );
        }
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
        {
            auto list = std::dynamic_pointer_cast<ENotifyingList<std::shared_ptr<EObject>>>( getEStructuralFeatures() );
            _ASSERTE(list);
            return list->add( otherEnd , notifications );
        }
    }
    return EClassifierImpl::eBasicInverseAdd(otherEnd, featureID, notifications);
    // End of user code
}


std::shared_ptr<ENotificationChain> EClassImpl::eBasicInverseRemove( const std::shared_ptr<EObject>& otherEnd, int featureID, const std::shared_ptr<ENotificationChain>& notifications )
{
    // Start of user code EClassImpl::eBasicInverseRemove
    switch( featureID )
    {
        case EcorePackage::ECLASS__EGENERIC_SUPER_TYPES:
        {
            auto list = std::dynamic_pointer_cast<ENotifyingList<std::shared_ptr<EObject>>>( getEGenericSuperTypes() );
            _ASSERTE(list);
            return list->remove( otherEnd , notifications );
        }
        case EcorePackage::ECLASS__EOPERATIONS:
        {
            auto list = std::dynamic_pointer_cast<ENotifyingList<std::shared_ptr<EObject>>>( getEOperations() );
            _ASSERTE(list);
            return list->remove( otherEnd , notifications );
        }
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
        {
            auto list = std::dynamic_pointer_cast<ENotifyingList<std::shared_ptr<EObject>>>( getEStructuralFeatures() );
            _ASSERTE(list);
            return list->remove( otherEnd , notifications );
        }
    }
    return EClassifierImpl::eBasicInverseRemove(otherEnd, featureID, notifications);
    // End of user code
}



//*********************************
// Initializations
//*********************************
std::shared_ptr<EList<std::shared_ptr<ecore::EClass>>> EClassImpl::initESuperTypes()
{
    // Start of user code EClassImpl::initESuperTypes
    return std::make_shared<EObjectEList<std::shared_ptr<ecore::EClass>,false,false,false>>( getThisPtr(), EcorePackage::ECLASS__ESUPER_TYPES);
    // End of user code
}

std::shared_ptr<EList<std::shared_ptr<ecore::EOperation>>> EClassImpl::initEOperations()
{
    // Start of user code EClassImpl::initEOperations
    return std::make_shared<EObjectEList<std::shared_ptr<ecore::EOperation>,true,true,true>>( getThisPtr(), EcorePackage::ECLASS__EOPERATIONS , EcorePackage::EOPERATION__ECONTAINING_CLASS);
    // End of user code
}

std::shared_ptr<EList<std::shared_ptr<ecore::EStructuralFeature>>> EClassImpl::initEStructuralFeatures()
{
    // Start of user code EClassImpl::initEStructuralFeatures
    return std::make_shared<EObjectEList<std::shared_ptr<ecore::EStructuralFeature>,true,true,true>>( getThisPtr(), EcorePackage::ECLASS__ESTRUCTURAL_FEATURES , EcorePackage::ESTRUCTURAL_FEATURE__ECONTAINING_CLASS);
    // End of user code
}

void EClassImpl::initEAllAttributes()
{
    // Start of user code EClassImpl::initEAllAttributes
    if (eAllAttributes_)
        return;

    std::vector<std::shared_ptr<EAttribute>> allAttributes, attributes;
    std::shared_ptr<EAttribute> eIDAttribute;
    for( const auto& eClass : *getESuperTypes() )
    {
        auto superAttributes = eClass->getEAllAttributes();
        for( const auto& attribute : *superAttributes )
        {
            allAttributes.push_back( attribute );
            if( attribute->isID() && !eIDAttribute )
                eIDAttribute = attribute;
        }
    }
    auto features = getEStructuralFeatures();
    for( const auto& feature : *features )
    {
        if( auto attribute = std::dynamic_pointer_cast<EAttribute>( feature ) )
        {
            attributes.push_back( attribute );
            allAttributes.push_back( attribute );
            if( attribute->isID() && !eIDAttribute )
                eIDAttribute = attribute;
        }
    }

    eIDAttribute_ = eIDAttribute;
    eAttributes_ = std::make_shared< ImmutableEList<std::shared_ptr<EAttribute>>>( std::move( attributes ) );
    eAllAttributes_ = std::make_shared< ImmutableEList<std::shared_ptr<EAttribute>>>( std::move( allAttributes ) );
    // End of user code
}

void EClassImpl::initEAllReferences()
{
    // Start of user code EClassImpl::initEAllReferences
    if (eAllReferences_)
        return;

    std::vector<std::shared_ptr<EReference>> allReferences, references;

    for( const auto& eClass : *getESuperTypes() )
    {
        auto superReferences = eClass->getEAllReferences();
        allReferences.insert( std::end( allReferences ), superReferences->begin(), superReferences->end() );
    }
    auto features = getEStructuralFeatures();
    for( const auto& feature : *features )
    {
        if( auto reference = std::dynamic_pointer_cast<EReference>( feature ) )
        {
            references.push_back( reference );
            allReferences.push_back( reference );
        }
    }
    eReferences_ = std::make_shared< ImmutableEList<std::shared_ptr<EReference>>>( std::move( references ) );
    eAllReferences_ = std::make_shared< ImmutableEList<std::shared_ptr<EReference>>>( std::move( allReferences ) );
    // End of user code
}

void EClassImpl::initEReferences()
{
    // Start of user code EClassImpl::initEReferences
    initEAllReferences();
    // End of user code
}

void EClassImpl::initEAttributes()
{
    // Start of user code EClassImpl::initEAttributes
    initEAllAttributes();
    // End of user code
}

void EClassImpl::initEAllContainments()
{
    // Start of user code EClassImpl::initEAllContainments
    initFeaturesSubSet();
    // End of user code
}

void EClassImpl::initEAllOperations()
{
    // Start of user code EClassImpl::initEAllOperations
    if (eAllOperations_)
        return;

    operationToOverrideMap_.reset();

    std::vector< std::shared_ptr< EOperation > > allOperations;
    for( const auto& eClass : *getESuperTypes() )
    {
        auto operations = eClass->getEAllOperations();
        allOperations.insert( std::end( allOperations ), operations->begin(), operations->end() );
    }
    int operationID = static_cast<int>( allOperations.size() );
    for( const auto& operation : *getEOperations() )
    {
        auto operationImpl = std::dynamic_pointer_cast<EOperationImpl>( operation );
        BOOST_ASSERT( operationImpl );
        operationImpl->setOperationID( operationID++ );
        allOperations.push_back( operationImpl );
    }
    eAllOperations_ = std::make_shared< ImmutableEList<std::shared_ptr<EOperation>>>( std::move( allOperations ) );
    // End of user code
}

void EClassImpl::initEAllStructuralFeatures()
{
    // Start of user code EClassImpl::initEAllStructuralFeatures
    if (eAllStructuralFeatures_)
        return;

    eAllContainments_.reset();
    eAllCrossReferences_.reset();
    nameToFeatureMap_.reset();

    std::vector< std::shared_ptr< EStructuralFeature > > allFeatures;
    for( const auto& eClass : *getESuperTypes() )
    {
        auto features = eClass->getEAllStructuralFeatures();
        allFeatures.insert( std::end( allFeatures ), features->begin(), features->end() );
    }
    int featureID = static_cast<int>( allFeatures.size() );
    for( const auto& feature : *getEStructuralFeatures() )
    {
        auto featureImpl = std::dynamic_pointer_cast<EStructuralFeatureImpl>( feature );
        BOOST_ASSERT( featureImpl );
        featureImpl->setFeatureID( featureID++ );
        allFeatures.push_back( featureImpl );
    }
    eAllStructuralFeatures_ = std::make_shared< ImmutableEList<std::shared_ptr<EStructuralFeature>>>( std::move( allFeatures ) );
    // End of user code
}

void EClassImpl::initEAllSuperTypes()
{
    // Start of user code EClassImpl::initEAllSuperTypes
    if (eAllSuperTypes_)
        return;

    std::vector< std::shared_ptr< EClass> > allSuperTypes;
    for( const auto& eClass : *getESuperTypes() )
    {
        auto superTypes = eClass->getEAllSuperTypes();
        allSuperTypes.insert( std::end( allSuperTypes ), superTypes->begin(), superTypes->end() );
        allSuperTypes.push_back( eClass );
    }
    eAllSuperTypes_ = std::make_shared< ImmutableEList<std::shared_ptr<EClass>>>( std::move( allSuperTypes ) );
    // End of user code
}

void EClassImpl::initEIDAttribute()
{
    // Start of user code EClassImpl::initEIDAttribute
    initEAllAttributes();
    // End of user code
}

void EClassImpl::initEGenericSuperTypes()
{
    // Start of user code EClassImpl::initEGenericSuperTypes
    eGenericSuperTypes_ = std::make_shared<EObjectEList<std::shared_ptr<ecore::EGenericType>,true,true,false>>(getThisPtr(), EcorePackage::ECLASS__EGENERIC_SUPER_TYPES );
    // End of user code
}

void EClassImpl::initEAllGenericSuperTypes()
{
    // Start of user code EClassImpl::initEAllGenericSuperTypes
    eAllGenericSuperTypes_ = std::make_shared<EObjectEList<std::shared_ptr<ecore::EGenericType>,false,false,false>>( getThisPtr(), EcorePackage::ECLASS__EALL_GENERIC_SUPER_TYPES);
    // End of user code
}




// Start of user code EClassImpl [declaration-end]

void EClassImpl::setModified( int featureID )
{
    switch( featureID )
    {
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
        {
            eAllAttributes_.reset();
            eAllStructuralFeatures_.reset();
            eAllReferences_.reset();
            eAllContainments_.reset();
            break;
        }
        case EcorePackage::ECLASS__EATTRIBUTES:
        {
            eAllAttributes_.reset();
            eAllStructuralFeatures_.reset();
            eAllContainments_.reset();
            break;
        }
        case EcorePackage::ECLASS__EREFERENCES:
        {
            eAllReferences_.reset();
            eAllStructuralFeatures_.reset();
            eAllContainments_.reset();
            break;
        }
        case EcorePackage::ECLASS__EOPERATIONS:
        {
            eAllOperations_.reset();
            eAllContainments_.reset();
            break;
        }
        case EcorePackage::ECLASS__ESUPER_TYPES:
        {
            eAllSuperTypes_.reset();
            eAllAttributes_.reset();
            eAllStructuralFeatures_.reset();
            eAllReferences_.reset();
            eAllContainments_.reset();
            break;
        }
    }
    const auto& subClasses = eSuperAdapter_->getSubClasses();
    for (const auto& weakSubClass : subClasses)
    {
        if ( auto subClass = weakSubClass.lock() )
            subClass->setModified( featureID );
    }
}

std::shared_ptr<EList<std::shared_ptr<EReference>>> EClassImpl::getEAllCrossReferences()
{
    initFeaturesSubSet();
    return eAllCrossReferences_;
}


void EClassImpl::initFeaturesSubSet()
{
    initEAllStructuralFeatures();

    if( eAllContainments_ )
        return;

    std::vector< std::shared_ptr< EReference > > allContainments;
    std::vector< std::shared_ptr< EReference > > allCrossReferences;
    auto eAllFeatures = getEAllStructuralFeatures();
    for( const auto& feature : *eAllFeatures )
    {
        if( auto reference = std::dynamic_pointer_cast<EReference>( feature ) )
        {
            if( reference->isContainment() )
            {
                if( !reference->isDerived() )
                    allContainments.push_back( reference );
            }
            else if( !reference->isContainer() )
            {
                if( !reference->isDerived() )
                    allCrossReferences.push_back( reference );
            }
        }
    }
    eAllContainments_ = std::make_shared< ImmutableEList<std::shared_ptr<EReference>>>( std::move( allContainments ) );
    eAllCrossReferences_ = std::make_shared< ImmutableEList<std::shared_ptr<EReference>>>( std::move( allCrossReferences ) );
}

void EClassImpl::initNameToFeatureMap()
{
    initEAllStructuralFeatures();
    
    if (nameToFeatureMap_)
        return;
    
    nameToFeatureMap_ = std::make_unique< std::unordered_map< std::string, std::shared_ptr<EStructuralFeature>>>();
    for (const auto& feature : *getEAllStructuralFeatures())
        nameToFeatureMap_->operator[](feature->getName()) = feature;
}

void EClassImpl::initOperationToOverrideMap()
{
    initEAllOperations();

    if (operationToOverrideMap_)
        return;

    operationToOverrideMap_ = std::make_unique< std::unordered_map< std::shared_ptr<EOperation>, std::shared_ptr<EOperation>>>();
    auto& allOperations = *getEAllOperations();
    auto size = static_cast<int>( allOperations.size() );
    for (int i = 0; i < size; ++i)
    {
        for (int j = size - 1; j > i; --j)
        {
            const auto& oi = allOperations.get( i );
            const auto& oj = allOperations.get( j );
            if ( oj->isOverrideOf( oi ))
                operationToOverrideMap_->operator[]( oi ) = oj;
        }
    }
}



// End of user code

