// *****************************************************************************
//
// This file is part of a MASA library or program.
// Refer to the included end-user license agreement for restrictions.
//
// Copyright (c) 2018 MASA Group
//
// *****************************************************************************

// *****************************************************************************
//    
// Warning: This file was generated by sof.generator.cpp Generator
// 
//*****************************************************************************
#include "ecore/impl/EClassImpl.hpp"
#include "ecore/EAnnotation.hpp"
#include "ecore/EAttribute.hpp"
#include "ecore/EClass.hpp"
#include "ecore/EClassifier.hpp"
#include "ecore/EGenericType.hpp"
#include "ecore/EOperation.hpp"
#include "ecore/EPackage.hpp"
#include "ecore/EReference.hpp"
#include "ecore/EStructuralFeature.hpp"
#include "ecore/ETypeParameter.hpp"
#include "ecore/EcoreFactory.hpp"
#include "ecore/EcorePackage.hpp"
#include "ecore/impl/EObjectEList.hpp"
#include "ecore/EList.hpp"


#include <cassert>
#include <iostream>
#include <sstream>

//Start of user code EClassImpl [declaration-includes]
#include "ecore/EcorePackage.hpp"
#include "ecore/EAdapter.hpp"
#include "ecore/impl/EStructuralFeatureImpl.hpp"
//End of user code


using namespace ecore;
using namespace ecore::impl;

//Start of user code EClassImpl [declaration-begin]
class EClassImpl::ESuperAdapter : public EAdapter
{
public:
    ESuperAdapter( EClassImpl& eClassImpl )
        : eClassImpl_( eClassImpl )
        , subClasses_( new BasicEList<std::shared_ptr<EClassImpl>, true>() )
    {

    }

    virtual ~ESuperAdapter()
    {

    }

    const std::shared_ptr<EList<std::shared_ptr<EClassImpl>>>& getSubClasses() const
    {
        return subClasses_;
    }

    virtual void notifyChanged( const std::shared_ptr<ENotification>& notification )
    {
        int eventType = notification->getEventType();
        auto eNotifier = std::dynamic_pointer_cast<EClassImpl>( notification->getNotifier() );
        if( eventType != ENotification::REMOVING_ADAPTER )
        {
            int featureID = notification->getFeature()->getFeatureID();
            if( featureID == EcorePackage::ECLASS__ESUPER_TYPES )
            {
                switch( eventType )
                {
                    case ENotification::SET:
                    case ENotification::RESOLVE:
                    {
                        boost::any oldValue = notification->getOldValue();
                        if( !oldValue.empty() )
                        {
                            auto eClass = boost::any_cast<std::shared_ptr<EClass>>( oldValue );
                            auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                            eClassImpl->eSuperAdapter_->getSubClasses()->remove( eNotifier );
                        }
                        boost::any newValue = notification->getNewValue();
                        if( !newValue.empty() )
                        {
                            auto eClass = boost::any_cast<std::shared_ptr<EClass>>( newValue );
                            auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                            eClassImpl->eSuperAdapter_->getSubClasses()->add( eNotifier );
                        }
                        break;
                    }
                    case ENotification::ADD:
                    {
                        boost::any newValue = notification->getNewValue();
                        if( !newValue.empty() )
                        {
                            auto eClass = boost::any_cast<std::shared_ptr<EClass>>( newValue );
                            auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                            eClassImpl->eSuperAdapter_->getSubClasses()->add( eNotifier );
                        }
                        break;
                    }
                    case ENotification::ADD_MANY:
                    {
                        boost::any newValue = notification->getNewValue();
                        if( !newValue.empty() )
                        {
                            auto eCollection = boost::any_cast<std::shared_ptr<EList<std::shared_ptr<EClass>>>>( newValue );
                            for( const auto& eClass : *eCollection )
                            {
                                auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                                eClassImpl->eSuperAdapter_->getSubClasses()->add( eNotifier );
                            }
                        }
                        break;
                    }
                    case ENotification::REMOVE:
                    {
                        boost::any oldValue = notification->getOldValue();
                        if( !oldValue.empty() )
                        {
                            auto eClass = boost::any_cast<std::shared_ptr<EClass>>( oldValue );
                            auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                            eClassImpl->eSuperAdapter_->getSubClasses()->remove( eNotifier );
                        }
                        break;
                    }
                    case ENotification::REMOVE_MANY:
                    {
                        boost::any oldValue = notification->getOldValue();
                        if( !oldValue.empty() )
                        {
                            auto eCollection = boost::any_cast<std::shared_ptr<EList<std::shared_ptr<EClass>>>>( oldValue );
                            for( const auto& eClass : *eCollection )
                            {
                                auto eClassImpl = std::dynamic_pointer_cast<EClassImpl>( eClass );
                                eClassImpl->eSuperAdapter_->getSubClasses()->remove( eNotifier );
                            }
                        }
                        break;
                    }
                }
            }
            eClassImpl_.setModified( featureID );
        }
    }

private:
    EClassImpl& eClassImpl_;
    std::shared_ptr<EList<std::shared_ptr<EClassImpl>>> subClasses_;
};
//End of user code

//*********************************
// Constructor / Destructor
//*********************************
//Start of user code EClassImpl::EClassImpl
EClassImpl::EClassImpl()
    : eSuperAdapter_( new ESuperAdapter( *this ) )
{
    eAdapters().add( eSuperAdapter_.get() );
}
//End of user code

//Start of user code EClassImpl::~EClassImpl
EClassImpl::~EClassImpl()
{
    eAdapters().remove( eSuperAdapter_.get() );
#ifdef SHOW_DELETION
    std::cout << "-------------------------------------------------------------------------------------------------\r\ndelete EClass "<< this << "\r\n------------------------------------------------------------------------ " << std::endl;
#endif
}
//End of user code

std::shared_ptr<EClass> EClassImpl::eStaticClass() const
{
    return EcorePackage::eInstance()->getEClass();
}

//*********************************
// Attribute Setter Getter
//*********************************
void EClassImpl::setAbstract(bool abstract)
{
    // Start of user code EClassImpl::setAbstract
    abstract_ = abstract;
    // End of user code
}


bool EClassImpl::isAbstract() const 
{
    // Start of user code EClassImpl::isAbstract
    return abstract_;
    // End of user code
}


void EClassImpl::setInterface(bool interface)
{
    // Start of user code EClassImpl::setInterface
    interface_ = interface;
    // End of user code
}


bool EClassImpl::isInterface() const 
{
    // Start of user code EClassImpl::isInterface
    return interface_;
    // End of user code
}

//*********************************
// Operations
//*********************************
std::shared_ptr<ecore::EOperation> EClassImpl::getEOperation(int operationID)
{
    // Start of user code EClassImpl::getEOperation
    std::cout << BOOST_CURRENT_FUNCTION << std::endl;
    throw "NotImplementedException";
    // End of user code
}


std::shared_ptr<ecore::EStructuralFeature> EClassImpl::getEStructuralFeature(int featureID)
{
    // Start of user code EClassImpl::getEStructuralFeature
    
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";
    // End of user code
}


std::shared_ptr<ecore::EStructuralFeature> EClassImpl::getEStructuralFeature(const std::string& featureName)
{
    // Start of user code EClassImpl::getEStructuralFeature
    
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";
    // End of user code
}


int EClassImpl::getFeatureCount()
{
    // Start of user code EClassImpl::getFeatureCount
    std::cout << BOOST_CURRENT_FUNCTION << std::endl;
    throw "NotImplementedException";
    // End of user code
}


int EClassImpl::getFeatureID(const std::shared_ptr<ecore::EStructuralFeature>& feature)
{
    // Start of user code EClassImpl::getFeatureID
    std::cout << BOOST_CURRENT_FUNCTION << std::endl;
    throw "NotImplementedException";
    // End of user code
}


std::shared_ptr<ecore::EGenericType> EClassImpl::getFeatureType(const std::shared_ptr<ecore::EStructuralFeature>& feature)
{
    // Start of user code EClassImpl::getFeatureType
    std::cout << BOOST_CURRENT_FUNCTION << std::endl;
    throw "NotImplementedException";
    // End of user code
}


int EClassImpl::getOperationCount()
{
    // Start of user code EClassImpl::getOperationCount
    std::cout << BOOST_CURRENT_FUNCTION << std::endl;
    throw "NotImplementedException";
    // End of user code
}


int EClassImpl::getOperationID(const std::shared_ptr<ecore::EOperation>& operation)
{
    // Start of user code EClassImpl::getOperationID
    std::cout << BOOST_CURRENT_FUNCTION << std::endl;
    throw "NotImplementedException";
    // End of user code
}


std::shared_ptr<ecore::EOperation> EClassImpl::getOverride(const std::shared_ptr<ecore::EOperation>& operation)
{
    // Start of user code EClassImpl::getOverride
    std::cout << BOOST_CURRENT_FUNCTION << std::endl;
    throw "NotImplementedException";
    // End of user code
}


bool EClassImpl::isSuperTypeOf(const std::shared_ptr<ecore::EClass>& someClass)
{
    // Start of user code EClassImpl::isSuperTypeOf
    std::cout << BOOST_CURRENT_FUNCTION << std::endl;
    throw "NotImplementedException";
    // End of user code
}

//*********************************
// References
//*********************************
std::shared_ptr<EList<std::shared_ptr<ecore::EAttribute>>> EClassImpl::getEAllAttributes() const
{
    // Start of user code EClassImpl::getEAllAttributes
    return const_cast<EClassImpl*>( this )->getEAllAttributes();
    // End of user code
}




std::shared_ptr<EList<std::shared_ptr<ecore::EReference>>> EClassImpl::getEAllContainments() const
{
    // Start of user code EClassImpl::getEAllContainments
    if( !eAllContainments_ )
        const_cast<EClassImpl*>( this )->eAllContainments_.reset( new EObjectEList<std::shared_ptr<ecore::EReference>, false, false, false>( getThisPtr(), EcorePackage::ECLASS__EALL_CONTAINMENTS ) );
    return eAllContainments_;
    // End of user code
}




std::shared_ptr<EList<std::shared_ptr<ecore::EGenericType>>> EClassImpl::getEAllGenericSuperTypes() const
{
    // Start of user code EClassImpl::getEAllGenericSuperTypes
    if( !eAllGenericSuperTypes_ )
        const_cast<EClassImpl*>( this )->eAllGenericSuperTypes_.reset( new EObjectEList<std::shared_ptr<ecore::EGenericType>, false, false, false>( getThisPtr(), EcorePackage::ECLASS__EALL_GENERIC_SUPER_TYPES ) );
    return eAllGenericSuperTypes_;
    // End of user code
}




std::shared_ptr<EList<std::shared_ptr<ecore::EOperation>>> EClassImpl::getEAllOperations() const
{
    // Start of user code EClassImpl::getEAllOperations
    if( !eAllOperations_ )
        const_cast<EClassImpl*>( this )->eAllOperations_.reset( new EObjectEList<std::shared_ptr<ecore::EOperation>, false, false, false>( getThisPtr(), EcorePackage::ECLASS__EALL_OPERATIONS ) );
    return eAllOperations_;
    // End of user code
}




std::shared_ptr<EList<std::shared_ptr<ecore::EReference>>> EClassImpl::getEAllReferences() const
{
    // Start of user code EClassImpl::getEAllReferences
    if( !eAllReferences_ )
        const_cast<EClassImpl*>( this )->eAllReferences_.reset( new EObjectEList<std::shared_ptr<ecore::EReference>, false, false, false>( getThisPtr(), EcorePackage::ECLASS__EALL_REFERENCES ) );
    return eAllReferences_;
    // End of user code
}




std::shared_ptr<EList<std::shared_ptr<ecore::EStructuralFeature>>> EClassImpl::getEAllStructuralFeatures() const
{
    // Start of user code EClassImpl::getEAllStructuralFeatures
    return const_cast<EClassImpl*>( this )->getEAllStructuralFeatures();
    // End of user code
}




std::shared_ptr<EList<std::shared_ptr<ecore::EClass>>> EClassImpl::getEAllSuperTypes() const
{
    // Start of user code EClassImpl::getEAllSuperTypes
    if( !eAllSuperTypes_ )
        const_cast<EClassImpl*>( this )->eAllSuperTypes_.reset( new EObjectEList<std::shared_ptr<ecore::EClass>, false, false, false>( getThisPtr(), EcorePackage::ECLASS__EALL_SUPER_TYPES ) );
    return eAllSuperTypes_;
    // End of user code
}




std::shared_ptr<EList<std::shared_ptr<ecore::EAttribute>>> EClassImpl::getEAttributes() const
{
    // Start of user code EClassImpl::getEAttributes
    if( !eAttributes_ )
        const_cast<EClassImpl*>( this )->eAttributes_.reset( new EObjectEList<std::shared_ptr<ecore::EAttribute>, false, false, false>( getThisPtr(), EcorePackage::ECLASS__EATTRIBUTES ) );
    return eAttributes_;
    // End of user code
}




std::shared_ptr<EList<std::shared_ptr<ecore::EGenericType>>> EClassImpl::getEGenericSuperTypes() const
{
    // Start of user code EClassImpl::getEGenericSuperTypes
    if( !eGenericSuperTypes_ )
        const_cast<EClassImpl*>( this )->eGenericSuperTypes_.reset( new EObjectEList<std::shared_ptr<ecore::EGenericType>, true, true, false>( getThisPtr(), EcorePackage::ECLASS__EGENERIC_SUPER_TYPES ) );
    return eGenericSuperTypes_;
    // End of user code
}




std::shared_ptr<ecore::EAttribute> EClassImpl::getEIDAttribute() const
{
    // Start of user code EClassImpl::getEIDAttribute
    return eIDAttribute_;
    // End of user code
}



std::shared_ptr<EList<std::shared_ptr<ecore::EOperation>>> EClassImpl::getEOperations() const
{
    // Start of user code EClassImpl::getEOperations
    if( !eOperations_ )
        const_cast<EClassImpl*>( this )->eOperations_.reset( new EObjectEList<std::shared_ptr<ecore::EOperation>, true, true, true>( getThisPtr(), EcorePackage::ECLASS__EOPERATIONS, EcorePackage::EOPERATION__ECONTAINING_CLASS ) );
    return eOperations_;
    // End of user code
}




std::shared_ptr<EList<std::shared_ptr<ecore::EReference>>> EClassImpl::getEReferences() const
{
    // Start of user code EClassImpl::getEReferences
    if( !eReferences_ )
        const_cast<EClassImpl*>( this )->eReferences_.reset( new EObjectEList<std::shared_ptr<ecore::EReference>, false, false, false>( getThisPtr(), EcorePackage::ECLASS__EREFERENCES ) );
    return eReferences_;
    // End of user code
}




std::shared_ptr<EList<std::shared_ptr<ecore::EStructuralFeature>>> EClassImpl::getEStructuralFeatures() const
{
    // Start of user code EClassImpl::getEStructuralFeatures
    if( !eStructuralFeatures_ )
        const_cast<EClassImpl*>( this )->eStructuralFeatures_.reset( new EObjectEList<std::shared_ptr<ecore::EStructuralFeature>, true, true, true>( getThisPtr(), EcorePackage::ECLASS__ESTRUCTURAL_FEATURES, EcorePackage::ESTRUCTURAL_FEATURE__ECONTAINING_CLASS ) );
    return eStructuralFeatures_;
    // End of user code
}




std::shared_ptr<EList<std::shared_ptr<ecore::EClass>>> EClassImpl::getESuperTypes() const
{
    // Start of user code EClassImpl::getESuperTypes
    if( !eSuperTypes_ )
        const_cast<EClassImpl*>( this )->eSuperTypes_.reset( new EObjectEList<std::shared_ptr<ecore::EClass>, false, false, false>( getThisPtr(), EcorePackage::ECLASS__ESUPER_TYPES ) );
    return eSuperTypes_;
    // End of user code
}




std::shared_ptr<EClassImpl> EClassImpl::getThisPtr() const
{
    return thisPtr_.lock();
}

void EClassImpl::setThisPtr(const std::shared_ptr<EClassImpl>& thisPtr)
{
    thisPtr_ = thisPtr;
    EClassifierImpl::setThisPtr(thisPtr);
}

boost::any EClassImpl::eGet(int featureID, bool resolve, bool coreType) const
{
    switch(featureID)
    {
        case EcorePackage::ECLASS__ABSTRACT:
            return isAbstract();
        case EcorePackage::ECLASS__EALL_ATTRIBUTES:
            return getEAllAttributes();
        case EcorePackage::ECLASS__EALL_CONTAINMENTS:
            return getEAllContainments();
        case EcorePackage::ECLASS__EALL_GENERIC_SUPER_TYPES:
            return getEAllGenericSuperTypes();
        case EcorePackage::ECLASS__EALL_OPERATIONS:
            return getEAllOperations();
        case EcorePackage::ECLASS__EALL_REFERENCES:
            return getEAllReferences();
        case EcorePackage::ECLASS__EALL_STRUCTURAL_FEATURES:
            return getEAllStructuralFeatures();
        case EcorePackage::ECLASS__EALL_SUPER_TYPES:
            return getEAllSuperTypes();
        case EcorePackage::ECLASS__EATTRIBUTES:
            return getEAttributes();
        case EcorePackage::ECLASS__EGENERIC_SUPER_TYPES:
            return getEGenericSuperTypes();
        case EcorePackage::ECLASS__EID_ATTRIBUTE:
            return getEIDAttribute();
        case EcorePackage::ECLASS__EOPERATIONS:
            return getEOperations();
        case EcorePackage::ECLASS__EREFERENCES:
            return getEReferences();
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
            return getEStructuralFeatures();
        case EcorePackage::ECLASS__ESUPER_TYPES:
            return getESuperTypes();
        case EcorePackage::ECLASS__INTERFACE:
            return isInterface();
    }
    return EClassifierImpl::eGet(featureID, resolve, coreType);
}

void EClassImpl::eSet(int featureID, const boost::any& newValue)
{
    switch(featureID)
    {
        case EcorePackage::ECLASS__ABSTRACT:
        {
            bool a = boost::any_cast<bool>(newValue);
            setAbstract(a);
            return;
        }
        case EcorePackage::ECLASS__INTERFACE:
        {
            bool i = boost::any_cast<bool>(newValue);
            setInterface(i);
            return;
        }
    }
    return EClassifierImpl::eSet(featureID, newValue);
}

void EClassImpl::eUnSet(int featureID)
{
    // Start of user code EClassImpl::eUnset
    std::cout << BOOST_CURRENT_FUNCTION << std::endl;
    throw "NotImplementedException";
    // End of user code
}


bool EClassImpl::eIsSet(int featureID) const
{
    switch(featureID)
    {
        case EcorePackage::ECLASS__ABSTRACT:
            return abstract_ != false;
        case EcorePackage::ECLASS__EALL_ATTRIBUTES:
            return eAllAttributes_ && !eAllAttributes_->empty();
        case EcorePackage::ECLASS__EALL_CONTAINMENTS:
            return eAllContainments_ && !eAllContainments_->empty();
        case EcorePackage::ECLASS__EALL_GENERIC_SUPER_TYPES:
            return eAllGenericSuperTypes_ && !eAllGenericSuperTypes_->empty();
        case EcorePackage::ECLASS__EALL_OPERATIONS:
            return eAllOperations_ && !eAllOperations_->empty();
        case EcorePackage::ECLASS__EALL_REFERENCES:
            return eAllReferences_ && !eAllReferences_->empty();
        case EcorePackage::ECLASS__EALL_STRUCTURAL_FEATURES:
            return eAllStructuralFeatures_ && !eAllStructuralFeatures_->empty();
        case EcorePackage::ECLASS__EALL_SUPER_TYPES:
            return eAllSuperTypes_ && !eAllSuperTypes_->empty();
        case EcorePackage::ECLASS__EATTRIBUTES:
            return eAttributes_ && !eAttributes_->empty();
        case EcorePackage::ECLASS__EGENERIC_SUPER_TYPES:
            return eGenericSuperTypes_ && !eGenericSuperTypes_->empty();
        case EcorePackage::ECLASS__EID_ATTRIBUTE:
            return eIDAttribute_ != nullptr;
        case EcorePackage::ECLASS__EOPERATIONS:
            return eOperations_ && !eOperations_->empty();
        case EcorePackage::ECLASS__EREFERENCES:
            return eReferences_ && !eReferences_->empty();
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
            return eStructuralFeatures_ && !eStructuralFeatures_->empty();
        case EcorePackage::ECLASS__ESUPER_TYPES:
            return eSuperTypes_ && !eSuperTypes_->empty();
        case EcorePackage::ECLASS__INTERFACE:
            return interface_ != false;
    }
    return EClassifierImpl::eIsSet(featureID);
}

boost::any EClassImpl::eInvoke(int operationID, const std::shared_ptr<EList<boost::any>>& arguments)
{
    // Start of user code EClassImpl::eInvoke
    switch( operationID )
    {
        case EcorePackage::ECLASS__GET_EOPERATION_EINT:
        {
            return getEOperation( boost::any_cast<int>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_ESTRUCTURAL_FEATURE_EINT:
        {
            return getEStructuralFeature( boost::any_cast<int>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_ESTRUCTURAL_FEATURE_ESTRING:
        {
            return getEStructuralFeature( boost::any_cast<std::string>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_FEATURE_COUNT:
        {
            return getFeatureCount();
        }
        case EcorePackage::ECLASS__GET_FEATURE_ID_ESTRUCTURALFEATURE:
        {
            return getFeatureID( boost::any_cast<std::shared_ptr<ecore::EStructuralFeature>>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_FEATURE_TYPE_ESTRUCTURALFEATURE:
        {
            return getFeatureType( boost::any_cast<std::shared_ptr<ecore::EStructuralFeature>>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_OPERATION_COUNT:
        {
            return getOperationCount();
        }
        case EcorePackage::ECLASS__GET_OPERATION_ID_EOPERATION:
        {
            return getOperationID( boost::any_cast<std::shared_ptr<ecore::EOperation>>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__GET_OVERRIDE_EOPERATION:
        {
            return getOverride( boost::any_cast<std::shared_ptr<ecore::EOperation>>( arguments->get( 0 ) ) );
        }
        case EcorePackage::ECLASS__IS_SUPER_TYPE_OF_ECLASS:
        {
            return isSuperTypeOf( boost::any_cast<std::shared_ptr<ecore::EClass>>( arguments->get( 0 ) ) );
        }
    }
    return boost::any();
    // End of user code
}


std::shared_ptr<ENotificationChain> EClassImpl::eBasicInverseAdd( const std::shared_ptr<EObject>& otherEnd, int featureID, const std::shared_ptr<ENotificationChain>& notifications )
{
    // Start of user code EClassImpl::eBasicInverseAdd
    switch( featureID )
    {
        case EcorePackage::ECLASS__EOPERATIONS:
        {
            auto list = std::dynamic_pointer_cast<NotifyingEList<std::shared_ptr<EObject>>>( getEOperations() );
            _ASSERTE( list );
            return list->add( otherEnd, notifications );
        }
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
        {
            auto list = std::dynamic_pointer_cast<NotifyingEList<std::shared_ptr<EObject>>>( getEStructuralFeatures() );
            _ASSERTE( list );
            return list->add( otherEnd, notifications );
        }
    }
    return EClassifierImpl::eBasicInverseAdd( otherEnd, featureID, notifications );
    // End of user code
}


std::shared_ptr<ENotificationChain> EClassImpl::eBasicInverseRemove( const std::shared_ptr<EObject>& otherEnd, int featureID, const std::shared_ptr<ENotificationChain>& notifications )
{
    // Start of user code EClassImpl::eBasicInverseRemove
    switch( featureID )
    {
        case EcorePackage::ECLASS__EGENERIC_SUPER_TYPES:
        {
            auto list = std::dynamic_pointer_cast<NotifyingEList<std::shared_ptr<EObject>>>( getEGenericSuperTypes() );
            _ASSERTE( list );
            return list->remove( otherEnd, notifications );
        }
        case EcorePackage::ECLASS__EOPERATIONS:
        {
            auto list = std::dynamic_pointer_cast<NotifyingEList<std::shared_ptr<EObject>>>( getEOperations() );
            _ASSERTE( list );
            return list->remove( otherEnd, notifications );
        }
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
        {
            auto list = std::dynamic_pointer_cast<NotifyingEList<std::shared_ptr<EObject>>>( getEStructuralFeatures() );
            _ASSERTE( list );
            return list->remove( otherEnd, notifications );
        }
    }
    return EClassifierImpl::eBasicInverseRemove( otherEnd, featureID, notifications );
    // End of user code
}


// Start of user code EClassImpl [declaration-end]



void EClassImpl::setModified( int featureID )
{
    switch( featureID )
    {
        case EcorePackage::ECLASS__ESTRUCTURAL_FEATURES:
        {
            eAllAttributes_.reset();
            eAllStructuralFeatures_.reset();
            eAllReferences_.reset();
            eAllContainments_.reset();
            break;
        }
        case EcorePackage::ECLASS__EATTRIBUTES:
        {
            eAllAttributes_.reset();
            eAllStructuralFeatures_.reset();
            eAllContainments_.reset();
            break;
        }
        case EcorePackage::ECLASS__EREFERENCES:
        {
            eAllReferences_.reset();
            eAllStructuralFeatures_.reset();
            eAllContainments_.reset();
            break;
        }
        case EcorePackage::ECLASS__EOPERATIONS:
        {
            eAllOperations_.reset();
            eAllContainments_.reset();
            break;
        }
        case EcorePackage::ECLASS__ESUPER_TYPES:
        {
            eAllSuperTypes_.reset();
            eAllAttributes_.reset();
            eAllStructuralFeatures_.reset();
            eAllReferences_.reset();
            eAllContainments_.reset();
            break;
        }
    }
    const auto& subClasses = eSuperAdapter_->getSubClasses();
    for( const auto& subClass : *subClasses )
        subClass->setModified( featureID );
}

std::shared_ptr<EList<std::shared_ptr<EStructuralFeature>>> EClassImpl::getEAllStructuralFeatures()
{
    if( !eAllStructuralFeatures_ )
    {
        std::vector< std::shared_ptr< EStructuralFeature > > allFeatures;
        for( const auto& eClass : *getESuperTypes() )
        {
            auto features = eClass->getEAllStructuralFeatures();
            allFeatures.insert( std::end( allFeatures ), features->begin(), features->end() );
        }
        int featureID = static_cast<int>(allFeatures.size());
        for( const auto& feature : *getEStructuralFeatures() )
        {
            auto featureImpl = std::dynamic_pointer_cast<EStructuralFeatureImpl>( feature );
            featureImpl->setFeatureID( featureID++ );
        }
        auto features = getEStructuralFeatures();
        allFeatures.insert( std::end( allFeatures ), features->begin(), features->end() );
        eAllStructuralFeatures_ = std::make_shared< ImmutableEList<std::shared_ptr<EStructuralFeature>>>( std::move( allFeatures ) );
        containments_.reset();
        crossReferences_.reset();
    }
    return eAllStructuralFeatures_;
}

std::shared_ptr<EList<std::shared_ptr<ecore::EAttribute>>> EClassImpl::getEAllAttributes()
{
    if( !eAllAttributes_ )
    {
        std::vector<std::shared_ptr<EAttribute>> allAttributes;
        for( const auto& eClass : *getESuperTypes() )
        {
            auto attributes = eClass->getEAllAttributes();
            allAttributes.insert( std::end( allAttributes ), attributes->begin(), attributes->end() );
        }
        auto features = getEStructuralFeatures();
        for( const auto& feature : *features )
        {
            if( auto attribute = std::dynamic_pointer_cast<EAttribute>( feature ) )
                allAttributes.push_back( attribute );
        }
        eAllAttributes_ = std::make_shared< ImmutableEList<std::shared_ptr<EAttribute>>>( std::move( allAttributes ) );
    }
    return eAllAttributes_;
}

void EClassImpl::initFeaturesSubSet()
{
    auto eAllFeatures = getEAllStructuralFeatures();
    containments_ = std::make_shared<BasicEList<std::shared_ptr<EStructuralFeature>, true>>();
    crossReferences_ = std::make_shared<BasicEList<std::shared_ptr<EStructuralFeature>, true>>();
    for( const auto& feature : *eAllFeatures )
    {
        if( auto reference = std::dynamic_pointer_cast<EReference>( feature ) )
        {
            if( reference->isContainment() )
            {
                if( !reference->isDerived() )
                    containments_->add( reference );
            }
            else if( !reference->isContainer() )
            {
                if( !reference->isDerived() )
                    crossReferences_->add( reference );
            }
        }
    }
}

std::shared_ptr<EList<std::shared_ptr<EStructuralFeature>>> EClassImpl::getContainments()
{
    if( !containments_ )
        initFeaturesSubSet();
    return containments_;
}

std::shared_ptr<EList<std::shared_ptr<ecore::EStructuralFeature>>> EClassImpl::getCrossReferences()
{
    if (!crossReferences_ )
        initFeaturesSubSet();
    return crossReferences_;
}

// End of user code

